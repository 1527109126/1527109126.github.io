{"meta":{"title":"别调P的小窝","subtitle":"","description":"别调P的个人小窝，记录自己学习web、开发、安全的笔记。分享自己的经验。","author":"别调P","url":"https://blog.bietiaop.com","root":"/"},"pages":[{"title":"","date":"2024-10-29T03:39:03.587Z","updated":"2024-10-29T03:39:03.587Z","comments":true,"path":"404.html","permalink":"https://blog.bietiaop.com/404.html","excerpt":"","text":"window.location.href = '/';"},{"title":"收藏夹","date":"2024-10-29T03:39:03.639Z","updated":"2024-10-29T03:39:03.639Z","comments":true,"path":"favorites.html","permalink":"https://blog.bietiaop.com/favorites.html","excerpt":"","text":"精品网站 评论"},{"title":"文章归档","date":"2024-10-29T03:39:03.639Z","updated":"2024-10-29T03:39:03.639Z","comments":true,"path":"archive.html","permalink":"https://blog.bietiaop.com/archive.html","excerpt":"","text":""},{"title":"友链","date":"2023-03-10T23:38:51.000Z","updated":"2023-03-10T23:38:54.000Z","comments":true,"path":"friends.html","permalink":"https://blog.bietiaop.com/friends.html","excerpt":"","text":"友链 交流区"},{"title":"作品","date":"2024-10-29T03:39:03.682Z","updated":"2024-10-29T03:39:03.682Z","comments":true,"path":"works.html","permalink":"https://blog.bietiaop.com/works.html","excerpt":"","text":"个人项目 参与的项目（Contributor） 评论"}],"posts":[{"title":"Github 学生认证申请指南（2023避坑）","slug":"other/github_education","date":"2023-09-06T10:05:52.000Z","updated":"2023-09-06T10:05:52.000Z","comments":true,"path":"2023/09/06/other/github-education/","link":"","permalink":"https://blog.bietiaop.com/2023/09/06/other/github-education/","excerpt":"","text":"申请地址GitHub Student Developer Pack - GitHub Education 申请方式首先需要有一个 Github 账号（先用自己的 QQ 邮箱或者常用的其他邮箱注册账号），并且登录 Github。 登录后点击右上角头像，接着点击 Settings ，进入设置页面。 在进入到的页面里将你的 Name 更改为你的英文名（拼音），将你的头像更改为你的个人照片，最好是与学生证上的照片一致。在 Bio 编辑框里写上你的个人简介（三个内容缺一不可），例如： A sophomore at Jinling Institute of Technology (https://www.jit.edu.cn/), liking Coding. Studying in school for cyberspace security. 修改完之后下拉保存（点击 Update Profile），在申请成功（收到成功邮箱后）为了防止个人信息泄露，可以修改你的头像和昵称。 接着在左侧菜单列表的 Access 里面找到 Emails 并点击打开，在 Add email address 中添加你的学校邮箱并验证。 验证好之后我们可以进入到上面提到的申请地址进行申请。 打开申请地址，登录你的 Github 账号，点击下方样式的按钮： 确认自己是学生，进入填写页面，按照要求填写信息（学校名将在你选择学校邮箱后自动填充） 注意在选择邮箱时选择自己的学校邮箱，否则不能申请，申请理由随便填写（最好用英文）。 在下一步骤上传图片，我们先不要自己点击按钮拍照，我们到学信网申请一个在线证明，然后保存成图片（可以截图），最后保存图片，拖拽文件上传到该页面。 学信网申请在线证明可以百度，在结果页面可以使用浏览器自带的翻译功能翻译成英文。 若有类型选择，可选择 Other 类型（因为我在续签的时候没有这个，所以随便找了张图） 最后提交即可。 等待结果邮件即可，成功后可以将 Github 个人信息修改。 以上步骤缺一都不能正常申请（个人信息是2023年的新坑，本人至少尝试了20多遍才通过）。","categories":[{"name":"Github","slug":"Github","permalink":"https://blog.bietiaop.com/categories/Github/"},{"name":"学生认证","slug":"Github/学生认证","permalink":"https://blog.bietiaop.com/categories/Github/%E5%AD%A6%E7%94%9F%E8%AE%A4%E8%AF%81/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://blog.bietiaop.com/tags/Github/"},{"name":"学生认证","slug":"学生认证","permalink":"https://blog.bietiaop.com/tags/%E5%AD%A6%E7%94%9F%E8%AE%A4%E8%AF%81/"},{"name":"申请指南","slug":"申请指南","permalink":"https://blog.bietiaop.com/tags/%E7%94%B3%E8%AF%B7%E6%8C%87%E5%8D%97/"},{"name":"避坑","slug":"避坑","permalink":"https://blog.bietiaop.com/tags/%E9%81%BF%E5%9D%91/"}]},{"title":"Rust 学习笔记（一）","slug":"rust/study/01","date":"2023-07-24T02:12:38.000Z","updated":"2023-07-24T02:12:38.000Z","comments":true,"path":"2023/07/24/rust/study/01/","link":"","permalink":"https://blog.bietiaop.com/2023/07/24/rust/study/01/","excerpt":"","text":"看的是 B 站 up “软件工艺师”的视频：https://www.bilibili.com/video/BV1hp4y1k7SV 起步编写 Hello Worldfn main() { println!(\"Hello World!\"); } 与大部分编程语言一样，Rust 也有 main 函数，如上所示。而 Rust 的后缀名为 .rs，当我们需要编译运行简单的 Rust 程序，只需要命令行运行 rustc： rustc helloworld.rs 此时同目录下会生成两个文件：&lt;同文件名&gt;.pdb、&lt;同文件名&gt;.exe。其中 pdb 带有调试信息，而 exe 为可执行程序，可直接运行。 当然，rustc 命令只适合小型项目或文件，若大型项目则需要 Cargo。 Cargo 是 Rust 的构建系统和包管理工具，安装 Rust 时默认是安装 Cargo 的。 使用 Cargo 创建项目运行命令创建项目： cargo new &lt;项目名称&gt; 使用 Cargo 创建项目会创建一个项目文件夹即项目名称，进入文件夹可以看到 Cargo 为我们创建了如下文件以及目录结构： &lt;项目名称&gt; ├── Cargo.toml └── src └── main.rs 除此之外还有一个 .gitignore 文件，为 git 的文件忽略配置文件，也就是说 Cargo 为我们初始化了 git 仓库。 Cargo.toml 为 Cargo 的配置文件，与 nodejs 中的 package.json 一样。 根据 Cargo 生成的目录结构来看，项目的源代码都应该放在 src 文件夹下，Cargo 为我们创建了一个 main.rs 文件。 使用 Cargo 编译项目运行命令编译项目： cargo build 运行此命令将创建可执行程序文件，第一次运行 cargo build 会在顶层目录生成 cargo.lock 文件，该文件不需手动修改。 上面命令生成可执行文件放在指定目录，如果我们想构建并运行项目，需要执行以下命令： cargo run 若我们只需要检查代码，确保能通过编译，我们可以使用以下命令： cargo check 该命令会检查代码文件是否能通过编译，并不会产生任何可执行文件。 如果我们需要进行发布的构建，需要在 build 命令加上参数： cargo build --release 此命令在编译时会进行优化，但是编译时间会比开发版更长。 加不加这个参数的编译目录也有区别，开发版在 target/debug，发布版在 target/debug。 经典例子——猜数游戏 目标 生成一个 1 到 100 间的随机数 提示玩家输入一个猜测 猜完之后 ，程序会提示猜测是太小了还是太大了 如果猜的正确，那么打印出一个庆祝信息，程序退出 基本输入输出use std::io; fn main() { println!(\"猜数\"); println!(\"猜一个数字\"); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(\"无法读取行\"); println!(\"你猜的数字是: {}\", guess); } 上面的代码作用试试获取用户的输入。 println!() 作用就是打印一行内容，在 C 语言中，我们要想在打印内容中拼接变量，需要用到 % 占位符：printf(\"数字为：%d\", num);，而在 Rust 中，我们使用的是 {}：println!(\"你猜的数字是: {}\", guess);，而 println!() 是宏，不是函数。我们如果想要获取用户输入，需要引入标准库 io：use std::io;。 我们使用 let 声明变量，在 Rust 中，所有的变量默认都是不可变的，我们要想使其可变，就要跟上面的代码一样加上 mun： let num = 1; // 不可变 let mut num2 = 1; // 可变 num2 = 3; 在上面的代码中 String::new() 新建了一个字符串类型实例，它是由标准库提供的，值为空的字符串。 再往下看，io 库中有一个函数 stdin，会返回类型 Stdin 的实例，它会被用作句柄（Handler）来处理终端中的标准输入。若我们不在文件开头引入 io 库，则需要这样写： std::io::stdin().read_line(&amp;mut guess).expect(\"无法读取行\"); 但是不推荐这样写。 通过 read_line 我们可以读取终端中用户的输入，因此我们需要传入我们的可变的字符串引用地址：&amp;mut guess。引用地址默认也是不可变的，因此我们需要把它变为可变的，加上 mut。 当然，read_line 方法也是有返回值的，它的返回值类型为 io::Result&lt;usize&gt; 泛型，此方法的返回值通常有两种：Ok 和 Err，并且返回值通常会带上附加值，供我们进行使用，而 io 库中这个方法也为我们提供了处理方法，即 expect，当 read_line 返回 Ok 时，expect 会提取出 Ok 中附加的值，并将这个值作为结果返回给用户。 生成随机数Rust 标准库没有生成随机数的方法，但是我们可以使用 rand 包，我们需要通过 Cargo 包管理进行安装，首先访问网站寻找库：crates.io: Rust Package Registry 找到 rand 包：rand - crates.io: Rust Package Registry 发现最新版本为 0.8.5，那么在顶层目录的 Cargo.toml 文件内添加依赖： 上面这种写法就是指定了一个版本，当在版本号前面添加 ^ 代表着与该版本 API 兼容的版本，通常取与其兼容的最高版本：“^0.8.5”。 当我们执行 cargo build 时同时会下载库。如果我们不主动更新库，那么 Cargo 将会一直使用与代码兼容的库的版本。 若我们想要更新库，可以使用命令 cargo update，此时 Cargo 将忽略 Cargo.lock 文件直接检查 Cargo.toml 内的版本，并且更新到与之兼容的小版本的最新版本，例如我在 Cargo.toml 内写的版本为 0.8.0，那么其会帮我们更新到 0.8.5 (0.8.x 中最新版)。其不会修改 Cargo.toml 文件，而是修改 Cargo.lock 文件，我们在更细完后可以看到 Cargo.lock 文件内的 rand 版本号为 0.8.5。 接下来我们使用 rand 包中的接口生成随机数： // .. 其他代码 use rand::Rng; // 使用 rand 包 fn main() { // .. 其他代码 let secret_number = rand::thread_rng().gen_range(1..=100); // 创建 1-100 随机数 println!(\"秘密数字是: {}\", secret_number); // .. 其他代码 } 版本 0.8.0 以后生成 1-100 随机数里面的参数不再是 1, 101，而是 1..=100。新版本用法如下： 1..100：左闭右开，即 1~99；1..=100：左闭右闭，即 1~100。 比较数字大小我们需要从标准库中引入 cmp 的 Ordering 类型，它有三个值：Less、Greater、Equal，我们声明了变量 guess 并且读取用户输入，我们声明的变量有一个方法 cmp，它会与另外一个（传参）值进行比较（Compare），如果大于就返回 Odering 类型中的 Greater，小于就是 Less，等于就是 Equal。 但是我们定义的是一个字符串 String 类型，但是我们要比较的是整数类型，在 Rust 中有许多整数类型，Rust 也自带有类型推断，而我们写的变量赋值默认类型即为 i32，后面会讲到。 因此我们需要转换一下类型，最好把字符串转为整数类型： let guess:u32 = guess.trim().parse().expect(\"请输入一个数字！\"); 因处理类型可以失败，因此需要使用 expect 处理。 我们之前已经声明了一个变量 guess，但是我们可以再次声明同名称变量来“隐藏（shadow）”旧变量，这一特性通常用在转换类型。 上面代码中，trim 用于去掉两端的空白，parse 进行类型转换。我们在声明变量时加上什么类型就转成什么类型。我们使用 u32 类型是因为 Rust 拥有类型推断功能，我们在后面用到 guess 时 Rust 推断出我们的 guess 取值在 1 ~ 100，因此自动推断类型为 u32（无符号整型）而非 i32，若我们只写到最开始的 guess 赋值，那么可以看到 guess 的类型为 i32。 接下来我们可以对两个数字进行比较： use std::io; use std::cmp::Ordering; use rand::Rng; fn main() { println!(\"猜数\"); println!(\"猜一个数字\"); let secret_number = rand::thread_rng().gen_range(1..=100); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess) .expect(\"无法读取行\"); let guess:u32 = guess.trim().parse().expect(\"请输入数字\"); match guess.cmp(&amp;secret_number) { Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; println!(\"你赢了\"), } } 其中 match 的左右就好比 switch，它允许代码根据条件进行运行。事实上，match 就是用来枚举的。 允许多次猜测——循环我们使用 loop 进行循环： loop { // ... 执行代码 } 我们调整一下代码顺序，将程序生成的随机数放到循环外面，提示以及输入放到循环里面： use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { println!(\"猜数\"); let secret_number: u32 = rand::thread_rng().gen_range(1..=100); loop { println!(\"猜一个数字\"); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess).expect(\"无法读取行\"); let guess: u32 = guess.trim().parse().expect(\"请输入数字\"); match guess.cmp(&amp;secret_number) { Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; println!(\"你赢了\"), } } } 此时，我们可以一直进行猜测，程序也会一直进行反馈。 接下来我们就需要处理猜对跳出循环。与其他语言循环一样，Rust 跳出循环也是用的 break： use rand::Rng; use std::cmp::Ordering; use std::io; fn main() { println!(\"猜数\"); let secret_number: u32 = rand::thread_rng().gen_range(1..=100); loop { println!(\"猜一个数字\"); let mut guess = String::new(); io::stdin().read_line(&amp;mut guess).expect(\"无法读取行\"); let guess: u32 = guess.trim().parse().expect(\"请输入数字\"); match guess.cmp(&amp;secret_number) { Ordering::Less =&gt; println!(\"太小了\"), Ordering::Greater =&gt; println!(\"太大了\"), Ordering::Equal =&gt; { println!(\"你赢了\"); break; } } } } 处理报错如果我们输入一个非数字字符，会出现如下报错： 还会看到我们在 expect 里面的提示内容“请输入数字”，若我们对错误进行处理而不是直接抛出错误使程序停止，那么就需要对返回内容使用枚举，之前提到过，expect 会返回两个内容：Ok 和 Err，因此我们可以对此进行枚举： let guess: u32 = match guess.trim().parse() { Ok(num) =&gt; num, Err(_) =&gt; continue, }; 这样的语法与 js 中的箭头函数很像，也只是很像，其中 continue 即跳出本次循环。 基础语法变量与可变性 声明变量使用 let 关键词 默认情况下，变量是不可变的（Immutable） 声明变量时，在变量前面加上 mut，就可以使变量可变。 变量与常量常量（Constant）：常量在绑定值以后也是不可变的，但它与不可变的变量有很多区别： 不可以使用 mut，常量永远都是不可变的 声明常量使用 const 关键字，它的类型必须被标注 常量可以在任何作用域内进行声明，包括全局作用域 常量只可以绑定到常量表达式，无法绑定导函数的调用结果或只能在运行时才能计算出的值 在程序运行期间，常量在其声明的作用域内一直有效 命名规范：Rust 里常量使用全大写字母，每个单词之间用下划线分开，例如：MAX_POINTS 隐藏（遮蔽）在 Rust 里可以使用相同的名字声明新的变量，新的变量就会 shadow （隐藏，遮蔽）之前声明的变量： fn main() { let x = 5; let x = x + 1; let x = x * 2; println!(\"The value of x is {}\", x); // 12 } shadow 和把变量标记为 mut 是不一样的： 如果不使用 let 关键字，那么重新给非 mut 的变量赋值会导致编译时错误 使用 let 声明的同名新变量，也是不可变的 而使用 let 声明的同名新变量，它的类型可以与之前不同 数据类型标量和复合类型Rust 是静态编译语言，在编译时必须知道所有变量的类型 基于使用的值，编译器通常能够推断出它的具体类型 但如果可能的类型比较多（例如把 String 转为整数的 parse 方法），就必须添加类型的标注，否则编译会报错。 标量类型一个标量类型代表一个单个的值 Rust 有四个主要的标量类型： 整数类型 整数类型没有小数部分 整数可以用下划线切割方便阅读，例如 12000 可以写为 12_000，没有影响 例如 u32 就是一个无符号的整数类型，占据 32 位的空间 无符号整数类型以 u 开头 有符号的整数类型以 i 开头 Rust 的整数类型列表如下： 长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 每种都分 i 和 u，以及固定的位数 有符号范围： $-2^{n-1}$ 到 $2^{n-1}-1$ 无符号范围： $0$ 到 $2^n-1$ isize 和usize 类型 isize 和 usize 类型的位数由程序运行的计算机的架构所决定： 如果是 64 位计算机，那就是 64 位的 …… 使用 isize 或 usize 的主要场景是对某种集合进行索引操作。 整数字面值 进制 例子 十进制 Decimal 98_222 十六进制 Hex 0xff 八进制 Octal 0o77 二进制 Binary 0b1111_0000 字节 Byte (仅限 u8) b’A’ 除了 byte 类型外，所有的数值字面值都允许使用类型后缀，例如 57u8，57 为整数，u8 为类型。 如通不太清楚应该使用哪种类型，可以使用 Rust 相应的默认类型： 整数的默认类型就是 i32；i32 总体上来说速度很快，即使在 64 位系统中。 整数溢出 例如：u8 的范围是 0~255，如果把 u8 的变量的值设为 256，那么： 调试模式下编译：Rust 会检查整数溢出，如果发生溢出，程序在运行时就会 panic 发布模式下（–release）编译：Rust 不会检查可能导致 panic 的整数溢出 如果溢出发生：Rust 会执行“环绕操作”：256 变成 0，257 变成 1 …… 但程序不会 panic 浮点类型 Rust 有两种基础的浮点类型，也就是含有小数部分的类型 f32，32 位，单精度 f64，64 位，双精度 Rust 的浮点类型使用了 IEEE-754 标准来表述 f64 是默认类型，因为在现代 CPU 上 f64 和 f32 的速度差不多，而且精度更高。 数值操作加、减、乘、除、取余略。 布尔类型 bool 字符类型 Rust 中 char 类型被用来描述语言中最基础的单个字符。 字符类型的字面值使用单引号 占用 4 字节大小 是 Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji 表情等。 U+0000 到 U+D7FF U+E000 到 U+10FFFF 复合类型 复合类型可以将多个值放在一个类型里。 Rust 提供了两种基础的复合类型：元组（Tuple）、数组 TupleTuple 可以将多个类型的多个值放在一个类型里 Touple 的长度是固定的，一旦声明就无法改变 创建 Tuple 在小括号里，将值用逗号分开 Tuple 中的每个位置都对应一个类型，Tuple 中各元素的类型不必相同 fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); println!(\"{}, {}, {}, \", tup.0, tup.1, tup.2); } 获取 Tuple 的元素值 可以使用模式匹配来解构（destructure）一个 Tuple 来获取元素的值 fn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); // 解构赋值 let (x, y, z) = tup; println!(\"{}, {}, {}, \", x, y, z); } 访问 Tuple 的元素 使用点标记法，例如第一个元素就为 变量.0，第二个元素为 变量.1 数组 数组也可以将多个值放在一个类型里 数组中每个元素的类型必须相同 数组的长度也是固定的，一旦声明之后不能边长也不能变短 如果想让数据存放在 stack（栈）上面而不是 heap（堆）上面，或者想保证有固定数量的元素，这时使用数组更有好处 数组没有 Vector 灵活（后面提到，实际 Vector 用的更多） Vector 和数组类似，它由标准库提供 Vector 的长度可以改变 如果不确定该用数组还是 Vector，那么就应该使用 Vector 声明数组let a = [1, 2, 3, 4, 5]; 数组的类型 数组的类型以这种形式表示：[类型; 长度] 例如：let a: [i32; 5] = [1, 2, 3, 4, 5]; 另一种声明数组的方法 如果数组的每个元素值都相同，那么可以在： 在中括号里指定初始值 然后是一个“;” 最后是数组的长度 例如：let a = [3; 5]; 它就相当于：let a = [3, 3, 3, 3, 3]; 访问数组的元素 数组是 Stack 上分配的单个块的内存 可以使用索引来访问数组的元素 let months = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ]; let first = months[0]; let second = months[1]; 如果访问的索引超出了数组的范围，那么： 编译可能会通过 运行会报错（runtime 时会 panic） Rust 不会允许其继续访问相应地址的内存 函数函数的声明 声明函数使用 fn 关键字 依照惯例，针对函数和变量名，Rust 使用 snake_case 命名规范： 所有的字母都是小写的，单词之间用下划线分开： fn main() { println!(\"hello world\"); another_function(); } fn another_function() { println!(\"Another function\"); } 函数的参数 parameters（定义函数的形参）, arguments（传入函数的实参） 在函数签名里，必须声明每个参数的类型： fn main() { another_function(5, 6); } fn another_function(x: i32, y: i32) { println!(\"the value of x is: {}\", x); println!(\"the value of y is: {}\", y); } 函数体中的语句与表达式 函数体由一系列语句组成，可选的由一个表达式结束 Rust 是一个基于表达式的语言 语句是执行一些动作的指令 表达式会计算产生一个值 fn main() { let y = 6; // 这是一个语句 } // 整个函数的定义也是一个语句 函数的定义也是语句 语句不返回值，所以不可以使用 let 将一个语句赋给一个变量 let x = (let y = 6); 这样写会报错，因为第一个等号右边不是表达式而是语句，语句不返回值（这与 C 语言不同），实际上语句返回的是一个空的 Tuple ()。 表达式是语句的组成部分，表达式有一个值，例如 let a = 3 + 5; 其中等式右边的就是一个表达式，而 5 这个字面值本身就是一个表达式，对应的值为 5。调用函数也是一个表达式，调用宏（例如 println ）也是一个表达式，下面代码中的代码块也是一个表达式： fn main() { let x = 5; let y = { let x = 1; x + 3 } println!(\"The value of y is: {}\", y); } 上面代码中我们声明了一个 y，等号右边为一个代码块，代码块中最后一行没有分号，因此这个代码块的值就为最后一个表达式执行后返回的值。 但是如果我们在 x + 3 后加上一个 ;，那么此代码块就是一个语句，没有返回值。 函数的返回值 在 -&gt; 符号后面声明函数返回值的类型，但是不可以为返回值命名 在 Rust 里面，返回值就是函数体里面最后一个表达式的值 若想提前返回，需使用 return 关键字，并指定一个值 大多数函数都是默认使用最后一个表达式作为返回值 fn five() -&gt; i32 { 5 } fn plus_five(x: i32) -&gt; { x + 5; } fn main() { let x = five(); let y = five(6); println!(\"The value of x is: {}\", x); println!(\"The value of y is: {}\", y); } 上面调用 five 函数的返回值为 5，因此 x 的输出就为 5。调用 plus_five 函数传入参数值为 6，函数中最后一个表达式值为 11，函数返回值就为 11，因此 y 为 11。 最后一个表达式后面不能加分号，否则就为一个语句，返回类型就为 Tuple，与我们指定的 i32 冲突。 注释// 单行注释 /* 多行 注释 */ 后面会讲到文档注释 控制流if 表达式 跟许多其他语言不一样的是，Rust 中的 if 表达式条件必须是 bool 类型。 fn main() { let number = 7; if number &lt; 5 { println!(\"condition was true\"); } else { println!(\"condition was false\"); } } 如果使用多于一个 else if，那么最好使用 match 来重构代码。 fn main() { let x = 3; match x % 4 { 0 =&gt; println!(\"x is divisible by 4\"), 1 =&gt; println!(\"x % 4 = 1\"), 2 =&gt; println!(\"x % 4 = 2\"), 3 =&gt; println!(\"x % 4 = 3\"), _ =&gt; println!(\"x % 4 = ?\"), } } 在 let 语句中使用 if 因为 if 是一个表达式，所以可以将它放在 let 语句中等号的右边 fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number isL {}\", number); } 循环loop 循环 loop 关键字告诉 Rust 反复地执行一块代码，直到你喊停。 可以在 loop 循环中使用 break 关键字来告诉程序何时停止循环。 fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } } println!(\"The result is : {}\", result); } 最终输出结果为 20。 while 条件循环 while 条件循环每次执行循环体之前都判断一次条件 fn main() { let mut number = 3; while number != 0 { println!(\"{}!\", number); number = number - 1; } println!(\"LIFTOFF!!!\"); } for 循环fn main() { let a = [10, 20, 30, 40, 50]l for element in a.iter() { println!(\"the value is: {}\", element); } } 下面例子实现倒计时： Range 由标准库提供，指定一个开始数字和一个结束数字，Range 可以生成它们之间的数字（不含结束），例如 let x = 1..4;，就会生成从 1 到 3 的 Range，rev 方法可以反转 Range，例如 let x = (1..4).rev(); 为从 3 到 1，与前面那个成反转关系。 fn main() { for number in (1..4).rev() { println!(\"{}!\", number); } println!(\"LIFTOFF!\"); }","categories":[{"name":"Rust","slug":"Rust","permalink":"https://blog.bietiaop.com/categories/Rust/"},{"name":"编程","slug":"Rust/编程","permalink":"https://blog.bietiaop.com/categories/Rust/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://blog.bietiaop.com/tags/Rust/"},{"name":"编程","slug":"编程","permalink":"https://blog.bietiaop.com/tags/%E7%BC%96%E7%A8%8B/"}]},{"title":"Canvas 使用纯色填充图片","slug":"web/front/react/Canvas图片填充颜色","date":"2023-07-20T04:30:28.000Z","updated":"2023-07-20T04:30:28.000Z","comments":true,"path":"2023/07/20/web/front/react/canvas-tu-pian-tian-chong-yan-se/","link":"","permalink":"https://blog.bietiaop.com/2023/07/20/web/front/react/canvas-tu-pian-tian-chong-yan-se/","excerpt":"","text":"我们在 Canvas 中绘制我们的图片图标时经常会遇到需要更改颜色的情况。本文将讲述一种方法。 原理使用临时的 Canvas DOM 绘制图片，并使用 globalCompositeOperation 加上 fillRect 绘制到目标（已有）的图像上，最后将临时的 Canvas 绘制到最重要实现的 Canvas 上。 需求分析我们需要绘制一个类似于“技能树”的效果，效果图片如下： 我们的这些图标图片都是远程并且颜色都为白色和灰色混合颜色（带有透明度），如下图所示： 我们通过一定条件进行判断我们要填充的颜色 imageColor（示例中有三种：黑色、白色、金色），大小 width 和 height 以及位置 x 、y 也是事先处理好的，具体要根据我们的业务进行调整。 const icon:HTMLImageElement = new Image(); // 创建图片 icon.setAttribute(\"crossOrigin\", \"anonymous\"); // 跨域图片处理 icon.src = \"xxxx\"; icon.onload = () =&gt; { applyImageColor( // 这个是我们待实现的函数 icon, // 图片 Dom imageColor, //填充颜色 x + 5, // 位置 x y + 5, // 位置 y width - 10, // 绘制宽度 height - 10 // 绘制高度 ); } 接下来我们就要实现 applyImageColor 函数，让它成为一个通用的绘制函数。 创建临时 Canvas 绘制图片我们要实现图片纯色填充，首先要创建一个临时 Canvas，将我们的图片绘制在上面： const applyImageColor = ( img: HTMLImageElement, color: string, x: number, y: number, width: number, height: number ) =&gt; { // 创建临时 Canvas const tempCanvas: HTMLCanvasElement = document.createElement(\"canvas\"); // 获取 CTX const tempCtx: CanvasRenderingContext2D | null = tempCanvas.getContext(\"2d\"); if (!tempCtx) return; // 将临时 Canvas 的宽高设置为图片的宽高 tempCanvas.width = img.width; tempCanvas.height = img.height; // 绘制原始图像 tempCtx.drawImage(img, 0, 0); // …… 后面进行处理 ① }; 我们就绘制了一个临时的 Canvas，大小为我们的图片大小，内容为我们的图片。 填充颜色Canvas Context2D 提供了一个属性 globalCompositeOperation， W3School 中是这么解释的： 定义和用法 globalCompositeOperation 属性设置或返回如何将一个源（新的）图像绘制到目标（已有）的图像上。 源图像 = 您打算放置到画布上的绘图。 目标图像 = 您已经放置在画布上的绘图。 也就是说我们可以绘制一个矩形放到已经绘制的图片上。 tempCtx.globalCompositeOperation = \"source-in\"; // 混合模式为 source-in tempCtx.fillStyle = color; // 将填充颜色设置为我们传入的颜色参数 tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height); // 填充矩形 此时我们绘制的矩形将填充我们之前绘制的图片。 将修改后的 Canvas 绘制到之前的 Canvas如果我们一共只需要一个 Canvas，我们可以直接在函数里面获取 Canvas 并进行绘制，如果我们有多个 Canvas，并且此函数为通用函数，我们可以通过传参方式传入我们的 Canvas。我们这里只需要一个 Canvas 来绘制我们的技能树，并且我们使用 React 框架，提供了 useRef 方便我们获取虚拟 DOM。 const canvas = canvasRef.current; // 获取 Canvas if (canvas) { // 获取 CTX const ctx = canvas.getContext(\"2d\"); if (ctx) { // 将临时画布绘制到目标画布 ctx.drawImage(tempCanvas, x, y, width, height); // 销毁临时画布 tempCanvas.remove(); } } 在临时 Canvas 使用完后进行销毁即可。 这样，我们就写了一个通用函数绘制纯色填充图片。 效果正如开头所示。 完整函数： const applyImageColor = ( img: HTMLImageElement, color: string, x: number, y: number, width: number, height: number ) =&gt; { const tempCanvas: HTMLCanvasElement = document.createElement(\"canvas\"); const tempCtx: CanvasRenderingContext2D | null = tempCanvas.getContext(\"2d\"); if (!tempCtx) return; tempCanvas.width = img.width; tempCanvas.height = img.height; // 绘制原始图像 tempCtx.drawImage(img, 0, 0); // 修改图像颜色 tempCtx.globalCompositeOperation = \"source-in\"; tempCtx.fillStyle = color; tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height); // 将修改后的图像绘制回画布 // 获取画布，这里使用了 React 的 useRef，在原生中可以使用 querySelector const canvas = canvasRef.current; if (canvas) { const ctx = canvas.getContext(\"2d\"); if (ctx) { ctx.drawImage(tempCanvas, x, y, width, height); // 销毁临时画布 tempCanvas.remove(); } } }; 使用我们写完此函数后就可以直接使用： 首先创建图片，在图片加载完成后，使用此函数，传参依次为： const icon:HTMLImageElement = new Image(); // 创建图片 icon.setAttribute(\"crossOrigin\", \"anonymous\"); // 跨域图片处理 icon.src = \"xxxx\"; // 图片地址 // 图片加载完成 icon.onload = () =&gt; { // 使用函数 applyImageColor( icon, // 图片 Dom imageColor, //填充颜色 x + 5, // 起始位置 x y + 5, // 起始位置 y width - 10, // 绘制的宽度 height - 10 // 绘制的高度 ); }","categories":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"Canvas","slug":"Canvas","permalink":"https://blog.bietiaop.com/tags/Canvas/"}]},{"title":"GetX 学习日志","slug":"flutter/getx/getx学习日志","date":"2023-07-10T00:15:13.000Z","updated":"2023-07-11T15:59:38.000Z","comments":true,"path":"2023/07/10/flutter/getx/getx-xue-xi-ri-zhi/","link":"","permalink":"https://blog.bietiaop.com/2023/07/10/flutter/getx/getx-xue-xi-ri-zhi/","excerpt":"","text":"前言急匆匆学完了 Flutter（当然后面肯定还要找时间巩固巩固），看的是 IT 营的 Flutter 基础课（也没记住多少），课程后面提到了 GetX，对于状态管理、路由、国际化等的帮助还是很大的，所以顺势就学了 GetX，官网的文档写的也不是特别完善，特别是对于我这种速成 Flutter 的零基础的，还是去 B 站找一个视频学习 GetX，初步筛选下，找到了这个视频：Flutter GetX零基础视频教程。当然，这个视频里面讲的都是一些基础快速入门的内容，例如路由部分讲的不是特别详细，我会参考其他文章并且实践得到最佳使用方法并且记录下来。对于例如 Obx 的特别基本的使用我就不再记录，最终目标是写出尽量标准化的工程代码。 这位 up 主还有配套的博客教程：Flutter GetX系列教程—介绍、Snackbar、Dialog、BottomSheet、Navigation、Obx | Jimi (liujunmin.com) 那么话不多说，开始学习。当然前面用的是真机进行测试的，后来换到了模拟器调试。 基本使用一般来说我们在写 Flutter App 的时候，会使用 MaterialApp 作为应用顶层，如这样： import 'package:flutter/material.dart'; void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( // 使用 MaterialApp 作为应用顶层 title: ..., home: ..., ); } } 如果我们使用 GetX 的一些功能例如路由功能，需要将 MaterialApp 替换为 GetMaterialApp ： import 'package:flutter/material.dart'; import 'package:get/get.dart'; // 首先引入 GetX void main() { runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return GetMaterialApp( // 使用 GetMaterialApp 作为应用顶层 title: ..., home: ..., ); } } 当然其他功能比如 Obx 等不需要替换程序入口。使用 GetX 可以让我们尽量少使用 Stateful 组件，多的使用 Stateless 组件，提高应用性能。 SnackbarSnackbar 的作用就是弹出一个顶部消息提醒，如下图所示： 当点击按钮的时候顶部会弹出提示信息。 Snackbar 基本使用此组件的基本使用如下： Get.snackbar( \"Snackbar 标题\", \"欢迎使用Snackbar\", ); 上面图片例子中，我们通过触发点击事件来执行此 Snackbar，提示标题为“Snackbar 标题”，提示内容为“欢迎使用Snackbar”。 完整组件代码如下： class DemoWidget extends StatelessWidget { const DemoWidget({super.key}); @override Widget build(BuildContext context) { // 按钮 return Center( child: ElevatedButton( onPressed: () { Get.snackbar( \"Snackbar 标题\", \"欢迎使用Snackbar\", ); }, child: const Text(\"按下去\"))); } } 我们查看一下参数列表： 可以看到 Snackbar 函数必传的参数为 title 和 message ，除此之外，Snackbar 函数还有其他可选参数，例如改变字体颜色，那么可以加上 colorText 参数，参数值类型为颜色类型： Get.snackbar( \"Snackbar 标题\", \"欢迎使用Snackbar\", colorText: const Color.fromARGB(255, 207, 76, 76), // 改变字体颜色 ); Snackbar 参数和说明 字段 属性 描述 title String 弹出的标题文字 message String 弹出的消息文字 colorText Color title和message的文字颜色 duration Duration Snackbar弹出的持续时间（默认3秒） instantInit bool 当false可以把snackbar 放在initState，默认true snackPosition SnackPosition 弹出时的位置，有两个选项【TOP，BOTTOM】默认TOP titleText Widget 弹出标题的组件，设置该属性会导致title属性失效 messageText Widget 弹出消息的组件，设置该属性会导致messageText属性失效 icon Widget 弹出时图标，显示在title和message的左侧 shouldIconPulse bool 弹出时图标是否闪烁，默认false maxWidth double Snackbar最大的宽度 margin EdgeInsets Snackbar外边距，默认zero padding EdgeInsets Snackbar内边距，默认EdgeInsets.all(16) borderRadius double 边框圆角大小，默认15 borderColor Color 边框的颜色，必须设置borderWidth，否则无效果 borderWidth double 边框的线条宽度 backgroundColor Color Snackbar背景颜色，默认Colors.grey.withOpacity(0.2) leftBarIndicatorColor Color 左侧指示器的颜色 boxShadows List Snackbar阴影颜色 backgroundGradient Gradient 背景的线性颜色 mainButton TextButton 主要按钮，一般显示发送、确认按钮 onTap OnTap 点击Snackbar事件回调 isDismissible bool 是否开启Snackbar手势关闭，可配合dismissDirection使用 showProgressIndicator bool 是否显示进度条指示器，默认false dismissDirection SnackDismissDirection Snackbar关闭的方向 progressIndicatorController AnimationController 进度条指示器的动画控制器 progressIndicatorBackgroundColor Color 进度条指示器的背景颜色 progressIndicatorValueColor Animation 进度条指示器的背景颜色，Animation snackStyle SnackStyle Snackbar是否会附加到屏幕边缘 forwardAnimationCurve Curve Snackbar弹出的动画，默认Curves.easeOutCirc reverseAnimationCurve Curve Snackbar消失的动画，默认Curves.easeOutCirc animationDuration Duration Snackbar弹出和小时的动画时长，默认1秒 barBlur double Snackbar背景的模糊度 overlayBlur double 弹出时的毛玻璃效果值，默认0 snackbarStatus SnackbarStatusCallback Snackbar弹出或消失时的事件回调（即将打开、已打开、即将关闭、已关闭） overlayColor Color 弹出时的毛玻璃的背景颜色 userInputForm Form 用户输入表单 DialogDialog 即弹出框，实际是对 AlertDialog 进行了封装。 当然我们可以对 Dialog 再次进行封装，以满足我们统一风格的定制。 我们可以新建一个 dart 文件，对 GetX 进行定制，包装成类或者函数供我们进行使用。 Dialog 的基本使用Get.defaultDialog(); 在没有传任何参数时，效果如上图所示，GetX 的对话框有默认的文字，当我们传入参数后，文字会被替换掉。 下面的代码是弹出一个带有确认和取消按钮的弹出框： Get.defaultDialog( title: \"弹出框\", content: const Text(\"内容\"), textConfirm: \"确定\", textCancel: \"取消\", ); 这个确定按钮是禁用的因为我们没有传入处理事件。 默认的确认、取消的按钮样式不是很好看，我们可以使用 confirm 和 cancel 参数来定义我们的确定和取消按钮。不过想要达到类似于 QQ 那样平铺分配的按钮，我们需要使用 actions 来定义我们的按钮列表，例如： Get.defaultDialog( title: \"弹出框\", content: const Text(\"内容\"), actions: [ Row( mainAxisAlignment: MainAxisAlignment.center, children: [ Expanded( flex: 1, child: TextButton( onPressed: () { Get.back(); }, child: const Text(\"取消\"), ), ), Expanded( flex: 1, child: ElevatedButton( onPressed: () { Get.back(); }, child: const Text(\"确定\"), ), ), ], ) ] ); 效果如下： 上面例子我们可以进一步修改，例如将 padding 设为 0 然后修改按钮样式或者使用 Container 替换掉默认按钮，以达到我们想要的效果，例如 QQ 的弹出框： 可以调整一下 padding 以及文字颜色背景颜色、圆角等达到类似的效果。 在调整好后可以进行封装等操作，方便我们在不同地方多次调用。 除此之外，其他的一些参数也是比较有用的。 Dialog 参数和说明 字段 属性 描述 title String 弹出的标题，默认（Alert) titlePadding EdgeInsetsGeometry 标题的内边距，默认（EdgeInsets.all(8)） titleStyle TextStyle 标题的样式 middleText String 中间内容区域显示的文字 middleTextStyle TextStyle 中间内容区域显示的文字样式 content Widget 弹出的内容，该值设置后middleText将无效 contentPadding EdgeInsetsGeometry 内容的内边距，默认（EdgeInsets.all(8)） onConfirm VoidCallback 确认按钮回调 onCancel VoidCallback 取消按钮回调 onCustom VoidCallback 自定义按钮回调 cancelTextColor Color 取消按钮文字的颜色 confirmTextColor Color 确认按钮文字的颜色 textConfirm String 确认按钮的文字 textCancel String 取消按钮的文字 textCustom String 自定义按钮的文字 confirm Widget 确认按钮的组件 cancel Widget 取消按钮的组件 custom Widget 自定义按钮的组件 backgroundColor Color 弹出框的背景颜色 barrierDismissible bool 是否可以通过点击背景关闭弹窗 buttonColor Color 按钮的文字颜色，根据按钮类型来设定不同的位置 radius double 弹出框的圆角大小，默认20 actions List 增加额外的子组件 onWillPop WillPopCallback 拦截关闭之前做一些操作 navigatorKey GlobalKey 用于打开对话框的key BottomSheetBottomSheet 是底部弹出层。 BottomSheet 的基本使用使用 Get.bottomSheet 来创建显示一个底部弹出层： Get.bottomSheet( // ....里面放入组件 ) 例如： Get.bottomSheet( Container( child: Wrap( children: [ ListTile( leading: const Icon(Icons.wb_sunny_outlined), title: const Text(\"白天模式\"), onTap: () { Get.changeTheme(ThemeData.light()); }, ), ListTile( leading: const Icon(Icons.wb_sunny), title: const Text(\"黑夜模式\"), onTap: () { Get.changeTheme(ThemeData.dark()); }, ) ], ), ) ); 我们实现的效果为：按下按钮执行 Get.bottomSheet 创建一个包含 “白天模式” 和 “黑夜模式” 的列表底部弹出。当点击对应的项时，使用 GetX 的功能进行主题的切换（后面会提到）。 上面的例子中，仅仅在底部弹出层里添加一个 Container，里面包含一个列表，没有配置背景色，因此没有背景，直接看到后面的半透明黑色幕布，当我们为 Container 添加一个背景色时，可以看到如下效果： Container( decoration: const BoxDecoration( borderRadius: BorderRadius.only( topLeft: Radius.circular(10), topRight: Radius.circular(10) ), // 左上、右上圆角 color: Colors.white, // 背景色 ), child: ...., ) 当然，上面是我们最原始的实现方法，也适合高度定制，Get.bottomSheet 里面有参数可以供我们修改背景色和圆角形状，具体参数列表如下： BottomSheet 参数和说明 字段 属性 描述 bottomsheet Widget 弹出的Widget组件 backgroundColor Color bottomsheet的背景颜色 elevation double bottomsheet的阴影 persistent bool 是否添加到路由中 shape ShapeBorder 边框形状，一般用于圆角效果 clipBehavior Clip 裁剪的方式 barrierColor Color 弹出层的背景颜色 ignoreSafeArea bool 是否忽略安全适配 isScrollControlled bool 是否支持全屏弹出，默认false useRootNavigator bool 是否使用根导航 isDismissible bool 点击背景是否可关闭，默认ture enableDrag bool 是否可以拖动关闭，默认true settings RouteSettings 路由设置 enterBottomSheetDuration Duration bottomsheet进入时的动画时间 exitBottomSheetDuration Duration bottomsheet退出时的动画时间 Navigation原生的 Flutter 自带了路由转跳，但是需要我们写许多代码，而 GetX 为我们进行了封装简化以及一些动画设置。 Navigation 的基本使用使用 to 方法进行路由转跳import 'package:path/home.dart'; Get.to(() =&gt; const Home()); 我们可以在函数参数里面配置切换动画，可参考下图的参数列表配置参数： 其中，最常用的为 transition 切换动画以及 arguments 参数传递。 接受转跳页面的传参： var data = await Get.to(() =&gt; const Home(), arguments: \"Hello World\"); // 转跳到 Home 页，并且携带参数 Hello World print(data); // 接收转跳到的 Home 页传来的数据 注意：await 的出现代表着该触发函数需要为 async。 当然，在转跳的 Home 页里，当我们返回转跳过来的父页面，想要传递数据要这样使用： Get.back(result: \"返回的数据\"); 转跳页面并携带参数的 arguments 函数参数在 toNamed 函数也是适用的。 使用 toNamed 方法进行路由转跳 在应用程序入口 GetMaterialApp 进行路由配置，当然我们可以写成一个路由文件然后进行导入。 import 'package:flutter/material.dart'; import 'package:path/home.dart'; import 'package:path/my.dart'; import 'package:get/get.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return GetMaterialApp( title: \"GetX\", initialRoute: \"/\", defaultTransition: Transition.zoom, getPages: [ GetPage(name: \"/\", page: () =&gt; const MyApp()), GetPage(name: \"/home\", page: () =&gt; const Home()), GetPage(name: \"/my\", page: () =&gt; const My(), transition: Transition.rightToLeft) ], home: MyDemo(), ); } } 其中 initialRoute 配置应用的根路由为：“/”。 defaultTransition 配置默认的切换路由动画效果 zoom。 getPages 配置我们的三个路由：/、/home、/my，并且使用 transition 参数来配置该路由的切换动画效果。后面会提到中间件的配置。getPages 配置比较多，可以参考官方文档进行配置。 在组件中调用 toNamed Get.toNamed(\"/my\"); 下图为 Get.toNamed 的参数列表 使用 back 方法进行返回上一页上面提到获取转跳的页面返回时的传参，使用的就是 Get.back();。 我们如果要返回上一个页面并携带参数，需要在 back 方法里加入 result 参数。 Get.back(result: \"数据\"); 使用 off 方法替换当前页面与 React Router 类似，其中转跳方法里面有参数 replace，即替换当前页面而不是新开一个页面，因此使用替换当前页面进行页面的转跳，不能通过 back 方法返回上一页，若使用 back 方法，则返回的是上上个页面（如果上上个页面转跳上个页面用的不是 off 方法）。 Get.off(() =&gt; const Home()); Get.off(\"/home\"); 使用 offAll 打开新页面，并关闭之前的所有页面Get.offAll(() =&gt; const Home()); Get.offAll(\"/home\"); arguments 传值的接收通过 Get.arguments 进行传参值的接收： class Home extends StatelessWidget { const Home({super.key}); @override Widget build(BuildContext context) { print(Get.arguments); // 打印出参数值 return Scaffold( appBar: ..., body: ..., ); } } parameters 传值的接收通过 Get.parameters 进行传值的接收，注意，parameters 传值类似于 URL 中的 parameters 传值，即路由地址加上 ?data=data。 class Home extends StatelessWidget { const Home({super.key}); @override Widget build(BuildContext context) { print(Get.parameters); // 打印出参数值 return Scaffold( appBar: ..., body: ..., ); } } 使用中间件进行认证等操作在使用 toNamed 方法配置路由列表的时候，使用 GetPage 进行路由的创建，其中 middlewares 参数配置我们的中间件，middlewares 里面为中间件的 List： // 白名单 GetPage( name: AppRoutes.Login, page: () =&gt; LoginView(), ), // 需要鉴权的路由 GetPage( name: AppRoutes.My, page: () =&gt; MyView(), middlewares: [ RouteAuthMiddleware(), ], ), 其中，RouteAuthMiddleware 为： 我们在中间件中需要重写 redirect 方法，我们在里面处理路由的跳转，例如满足条件继续加载到目标路由或者不满足条件，跳转到登录页等。 如果我们不进行其他处理，继续跳转到目标路由，我们可以返回一个 null，如果进行跳转，可以直接返回一个 RouteSettings 函数，参数有两个：name 即路由名称地址、arguments 即传参，都是可选值，但是如果 name 不配置的话，会导致报错喔。 class RouteAuthMiddleware extends GetMiddleware { //需要继承GetMiddleware @override //需要实现系统的该方法 RouteSettings? redirect(String? route) { //根据条件进行判断,满足条件进行跳转,否则不进行跳转（return null） if(满足条件) { return null; // 表示跳转到目标路由 } return RouteSettings(name: \"/login\",arguments: {}); // 同时传参 } } Obx 响应式状态管理定义 Obx 变量的三种方式 第一种 使用 Rx{Type} final name = RxString(''); // 字符串 final isLogged = RxBool(false); // 布尔 final count = RxInt(0); // 整型 final balance = RxDouble(0.0); // 浮点数 final items = RxList&lt;String&gt;([]); // List final myMap = RxMap&lt;String, int&gt;({}); // Map 第二种 使用 Rx，规定泛型 Rx&lt;Type&gt;。 final name = Rx&lt;String&gt;(''); // 字符串 final isLogged = Rx&lt;Bool&gt;(false); // 布尔 final count = Rx&lt;Int&gt;(0); // 整型 final balance = Rx&lt;Double&gt;(0.0); // 浮点数 final number = Rx&lt;Num&gt;(0); // 数字 final items = Rx&lt;List&lt;String&gt;&gt;([]); // 字符串 List final myMap = Rx&lt;Map&lt;String, int&gt;&gt;({}); // 字符串、数字 List // 自定义类 - 可以是任何类 final user = Rx&lt;User&gt;(); 第三种 只需添加 .obs 作为 value 的属性。（更实用、更简单、更可取的方法） final name = ''.obs; final isLogged = false.obs; final count = 0.obs; final balance = 0.0.obs; final number = 0.obs; final items = &lt;String&gt;[].obs; final myMap = &lt;String, int&gt;{}.obs; // 自定义类 - 可以是任何类 final user = User().obs; 对于 Obx 的基础使用我这里就不再记录，因为后面会用到 GetXController 对 Obx 进行进阶使用，更符合写项目时候的代码习惯，如果结合 GetXController 使用能够理解的话，那么 Obx 的基础使用就自然而然就会了。 下面先讲述结合 GetXController 使用 Obx，后面再对 GetXController 进行具体记录。 当然，在使用 GetXController 进行控制 Obx 变量时，我们最好将变量及其操作函数放在一个类里面并放到单独的文件内，例如： class CounterController extends GetxController { var count = 0.obs; increment() =&gt; count++; clear() =&gt; count.value = 0; } 当我们在使用的时候，只需要引入此文件，在组件里面进行初始化等操作。 例如我们在主页面初始化控制器，使用 Get.put() 方法初始化一个控制器并赋值给类型为 CounterController （我们创建的控制器类）的变量 c： class DemoWidget extends StatelessWidget { DemoWidget({super.key}); final CounterController c = Get.put(CounterController()); // 初始化控制器 @override Widget build(BuildContext context) { return Center( child: Column(children: [ Container( margin: const EdgeInsets.only(top: 20), child: Obx(() =&gt; Text(\"点击了${c.count} 次\")), // 使用值 ), ElevatedButton( onPressed: () { c.increment(); // 执行操作函数 }, child: const Text(\"点击＋1\")), ElevatedButton( onPressed: () { c.clear(); // 执行操作函数 }, child: const Text(\"清除\")), ]), ); } } 我们使用变量的时候需要在外面包裹 Obx 函数。 若我们在其他组件里想要调用相同的控制器，可以在该文件里引入我们控制器类所在的文件（如果其他组件与上面的这个主页面组件在一个文件里就不需要重复引入），并且在组件里使用 Get.find() 方法找到正在使用的相同控制器： import 'package:flutter/material.dart'; // getx import 'package:get/get.dart'; // 我们的控制器类放到了该文件内 import './store.dart'; class Test extends StatelessWidget { final CounterController c = Get.find&lt;CounterController&gt;(); // 找到控制器并赋值给 c Test({super.key}); @override Widget build(BuildContext context) { return Obx(() =&gt; Text(\"点击了${c.count} 次\")); // 使用 } } 这样，在主页面“清除”按钮后加上这个 Test 组件，运行可看到如下效果： GetXControllerGetXController 主要作用就是 UI 代码和业务逻辑的分离。在前面记录的 Obx 的使用，他就是结合了 GetXController 进行管理的，并且其中 Obx() 即其中的一种 三种创建方式首先： class MyController extends GetxController { 第一种 var teacher = Teacher(); void convertToUpperCase() { teacher.name.value = teacher.name.value.toUpperCase(); } 第二种 var teacher = Teacher(name: \"Jimi\", age: 18).obs; void convertToUpperCase() { teacher.update((val) { teacher.value.name = teacher.value.name.toString().toUpperCase(); }); } 第三种 var teacher = Teacher(); void convertToUpperCase() { teacher.name.value = teacher.name.value.toUpperCase(); update(); } } 这样把它们放在 MyController 类（继承 GetxController）里，就实现了控制器的创建。 实例化控制器并使用（三种使用方式）例如我们提前创建好上方的控制器类，下面要在组件里面实例化： final MyController myController = Get.put(MyController()); 实例化之后可以在子组件里进行使用，有三种方式： 第一种 Obx(() =&gt; Text( \"我的名字是 ${myController.teacher.name}\", style: TextStyle(color: Colors.red, fontSize: 30), )), 第二种 GetX&lt;MyController&gt;( init: MyController(), builder: (controller) { return Text( \"我的名字是 ${controller.teacher.name}\", style: TextStyle(color: Colors.green, fontSize: 30), ); }, ), 第三种 GetBuilder&lt;MyController&gt;( init: myController, builder: (controller) { return Text( \"我的名字是 ${controller.teacher.name}\", style: TextStyle(color: Colors.green, fontSize: 30), ); }, ), 在前面的 Obx 的使用中已经介绍过第一种使用方法了。 事件监听上面我们已经学会了创建控制器，这里我们简单的创建一个： class WorkersController extends GetxController { var count = 0.obs; void increment() { count++; } } 想要实现事件的监听，我们需要在类里重写 onInit 事件： @override void onInit() { // 监听count的值，当它发生改变的时候调用 ever(count, (callback) =&gt; print(\"ever----$count\")); // 监听多个值，当它们发生改变的时候调用 everAll([count], (callback) =&gt; print(\"everAll----$count\")); // count值改变时调用，只执行一次 once(count, (callback) =&gt; print(\"once----$count\")); // 用户停止打字时1秒后调用，主要是防抖 debounce(count, (callback) =&gt; print(\"debounce----$count\")); // 忽略3秒内的所有变动 interval(count, (callback) =&gt; print(\"interval----$count\")); super.onInit(); } 生命周期在创建控制器类的时候，我们可以重写生命周期方法： @override void onInit() { // TODO: implement onInit print(\"初始化\"); super.onInit(); } @override void onReady() { // TODO: implement onReady print(\"加载完成\"); super.onReady(); } @override void onClose() { // TODO: implement onClose print(\"控制器被释放\"); super.onClose(); } 然后实例化使用： GetBuilder&lt;MyLifecycleController&gt;( initState: (data) =&gt; myLifecycleController.increment(), dispose: (_) =&gt; myLifecycleController.cleanTask(), builder: (controller) { return Text( \"计数器值为: ${myLifecycleController.count}\", style: TextStyle(color: Colors.green, fontSize: 30), ); }, ), 上面代码当组件销毁的时候会执行 cleanTask() 清除计数器数据，初始化的时候会执行 increment()。 UniqueID我们在开发的过程中会碰到一种情况，就是多个地方引用了同一个属性，但我只想单独更新某一个地方，那么就可以用UniqueID来进行区分。 在创建控制器的时候加入 UniqueID： import 'package:get/get.dart'; class CountController extends GetxController { var count = 0; void increment() { count++; update(['jimi_count']); // 在这里写入 id } void increment2() { count++; update(); } } 在实例化使用的时候： GetBuilder&lt;CountController&gt;( id: 'jimi_count', // 加入 id builder: (controller) { return Text( \"计数器值为: ${controller.count}\", style: TextStyle(color: Colors.green, fontSize: 30), ); }, ), GetBuilder&lt;CountController&gt;( builder: (controller) { return Text( \"计数器值为: ${controller.count}\", style: TextStyle(color: Colors.green, fontSize: 30), ); }, ), 此时如果触发 increment() ，上面的组件会显示 count 自增1，而下面的不会，触发 increment2()，下面的组件会在上面的组件的显示的 count 的值的基础上自增1，也就是说触发哪个 increment 都会导致 count 自增1，但是根据 id 的不同（2中没有标明id，但是这种情况下与1中指定的有所区分），组件显示的也会不同，标有相应id的组件会显示变化的值。 例如此时的 children 如下： children: [ GetBuilder&lt;CountController&gt;( builder: (controller) { return Text( \"计数器值为: ${controller.count}\", style: TextStyle(color: Colors.red, fontSize: 30), ); }, ), GetBuilder&lt;CountController&gt;( builder: (controller) { return Text( \"计数器值为: ${controller.count}\", style: TextStyle(color: Colors.red, fontSize: 30), ); }, ), GetBuilder&lt;CountController&gt;( id: 'jimi_count', builder: (controller) { return Text( \"计数器值为: ${controller.count}\", style: TextStyle(color: Colors.green, fontSize: 30), ); }, ), SizedBox( height: 20, ), ElevatedButton( onPressed: () =&gt; countController.increment(), child: Text(\"增加\")), ElevatedButton( onPressed: () =&gt; countController.increment2(), child: Text(\"增加2\")) ], 当我们点击”增加“按钮时，第一个和第二个组件同时会变化（因为没有指定id，与已指定id的有所区别），变化后的值为1，第三个组件的值不会变化，仍为0。当我们两次点击”增加2“按钮时，第三个组件会变化（第一第二无变化），变化后的值为3，因为我们指定了id，如果再加上同一个id的组件，值内容也会跟第三个组件一样变化，第一第二个组件不变化，值仍为1。再点击”增加“按钮时，第一第二个组件会变化，变化后的值为4，第三个组件仍为3。 看上面的文字有点绕脑子，自己手写一遍就会非常清晰明了。 国际化配置程序入口在 GetMaterialApp 中配置国际化： GetMaterialApp( title: \"GetX\", translations: Messages(), locale: Locale('zh', 'CN'), //设置默认语言 fallbackLocale: Locale(\"zh\", \"CN\"), // 在配置错误的情况下,使用的语言 home: InternationalizationExample(), ); 创建国际化类创建一个类继承 Translations，重写 keys，类型为 Map。 import 'package:get/get.dart'; class Messages extends Translations { @override // TODO: implement keys Map&lt;String, Map&lt;String, String&gt;&gt; get keys =&gt; { 'zh_CN': { 'hello': \"你好, 世界\" }, 'en_US': { 'hello': 'hello world' } }; } 创建控制器类，用于切换语言创建一个控制器类，写入切换语言函数 changeLanguage，传入 languageCode 和 countryCode。然后使用 Locale 函数传入 languageCode 和 countryCode 获取地区参数。我们的语言类型组成为 zh_CN 用字符 _ 隔开的。其中 zh 为我们所指的 languageCode，CN 为我们所指的 countryCode。因此在我们切换语言传入参数的时候，languageCode 和 countryCode 要对应我们配置的如 zh_CN 的 zh 和 CN 两个部分，参考下面的实例化控制器并使用。 函数里使用 Get.updateLocale() 切换语言，传入参数为使用 Locale 获取到的地区参数。 import 'dart:ui'; import 'package:get/get.dart'; class MessagesController extends GetxController { void changeLanguage(String languageCode, String countryCode) { var locale = Locale(languageCode, countryCode); Get.updateLocale(locale); } } 实例化控制器并使用使用国际化语言只需要在字符串后面加上 .tr。GetX 会根据配置的国际化类里的内容转换为相应的内容。例如我们在 zh_CN 配置的内容为： 'zh_CN': { 'hello': \"你好, 世界\" }, 我们在使用 ‘hello’.tr 会获取中文语言中 key 为 ‘hello’ 的 Map 键的值，即为 你好，世界。 import 'package:flutter/material.dart'; import 'package:flutter_getx_example/GetXControllerWorkersExample/WorkersConroller.dart'; import 'package:flutter_getx_example/InternationalizationExample/MessagesCnotroller.dart'; import 'package:get/get.dart'; class InternationalizationExample extends StatelessWidget { final MessagesController messagesController = Get.put(MessagesController()); @override Widget build(BuildContext context) { return Scaffold( appBar: ..., body: Center( child: Column( children: [ Text('hello'.tr), // 使用国际化语言 ElevatedButton( onPressed: () =&gt; messagesController.changeLanguage('zh', \"CN\"), child: Text(\"切换到中文\") ), SizedBox(height: 20,), ElevatedButton( onPressed: () =&gt; messagesController.changeLanguage('en', \"US\"), child: Text(\"切换到英文\") ), ], ), ), ); } } 在上面的代码中使用了切换语言的函数 changeLanguage，传入两个参数 languageCode 和 countryCode 分别为 zh 和 CN，对应 zh_CN。 依赖注入在上面的笔记中，我们使用 Get.put(MyController()) 来进行控制器实例的创建，其实 GetX 还提供很多创建实例的方法，可根据不同的业务来进行创建，接下来我们简单介绍一下几个最常用的： Get.put()：不使用控制器实例也会被创建 Get.lazyPut()：懒加载方式创建实例，只有在使用时才创建 Get.putAsync()：Get.put() 的异步版本 Get.create()：每次使用都会创建一个新的实例 代码演示 创建控制器 import 'package:flutter_getx_example/ObxCustomClassExample/Teacher.dart'; import 'package:get/get.dart'; class MyController extends GetxController { var teacher = Teacher(); void convertToUpperCase() { teacher.name.value = teacher.name.value.toUpperCase(); } } 实例化控制器并使用 Get.put() 即使不使用控制器实例也会被创建；tag 将用于查找具有标签名称的实例；控制器在不使用时被处理，但如果永久为真，则实例将在整个应用程序中保持活动状态。 final MyController myController = Get.put(MyController(), permanent: true); Get.lazyPut() 实例将在使用时创建，它类似于 permanent，区别在于实例在不使用时被丢弃；但是当它再次被需要使用时，GetX 将重新创建实例。 Get.lazyPut(()=&gt; MyController()); Get.lazyPut(()=&gt; MyController(), tag: \"instancel\"); Get.putSync() 为 Get.put() 异步版本。 Get.putAsync&lt;MyController&gt;(() async =&gt; await MyController()); Get.create() 每次都将返回一个新的实例。 Get.create&lt;MyController&gt;(() =&gt; MyController()); 使用时： // 放在 onPressed 触发： onPressed: () { // 实例使用的 tag 创建 // Get.find&lt;MyController&gt;(tag: 'instancel'); Get.find&lt;MyController&gt;(); }, Get Service这个类就像一个 GetxController，它共享相同的生命周期 onInit()、onReady()、onClose()。 但里面没有 “逻辑”。它只是通知GetX的依赖注入系统，这个子类不能从内存中删除。所以如果你需要在你的应用程序的生命周期内对一个类实例进行绝对的持久化，那么就可以使用 GetxService。 创建 Service想要创建 Service，我们需要定义一个类继承 GetxService： import 'package:get/get.dart'; import 'package:shared_preferences/shared_preferences.dart'; class Service extends GetxService { Future&lt;void&gt; getCounter() async { SharedPreferences prefs = await SharedPreferences.getInstance(); int count = (prefs.getInt(\"counter\") ?? 0) + 1; print(\"count 的值为: $count\"); await prefs.setInt(\"counter\", count); } } 初始化 Service我们需要创建一个初始化函数并在运行程序前进行调用： 在初始化函数中我们需要使用 async-await 等待所有我们定义的服务启动成功，在 main 函数中也使用 async-await 进行调用，确保所有的服务启动成功。 import 'package:flutter/material.dart'; import 'package:flutter_getx_example/GetXServiceExample/GetXServiceExample.dart'; import 'package:flutter_getx_example/GetXServiceExample/Service.dart'; import 'package:get/get.dart'; /// 初始化服务 Future&lt;void&gt; main() async { await initServices(); runApp(MyApp()); } Future&lt;void&gt; initServices() async { print(\"初始化服务\"); await Get.putAsync(() async =&gt; await Service()); print(\"所有服务启动\"); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return GetMaterialApp( title: \"GetX\", home: GetXServiceExample(), ); } } 调用 Service import 'package:flutter/material.dart'; import 'package:flutter_getx_example/GetXServiceExample/Service.dart'; import 'package:get/get.dart'; class GetXServiceExample extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"GetX Service\"), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ ElevatedButton( onPressed: () { Get.find&lt;Service&gt;().getCounter(); }, child: Text(\"点我加1\")) ], ), ), ); } } Binding在我们使用 GetX 状态管理器的时候，往往每次都是用需要手动实例化一个控制器，这样的话基本页面都需要实例化一次，这样就太麻烦了，而 Binding 能解决上述问题，可以在项目初始化时把所有需要进行状态管理的控制器进行统一初始化，接下来看代码演示： 声明需要进行的绑定控制器类下面有三个文件： ① AllControllerBinding.dart在这个文件中创建一个类继承 Bindings，重写 dependencies() 方法，在这个方法中启动我们所有的控制器： import 'package:flutter_getx_example/GetXBindingExample/controller/BindingHomeController.dart'; // 引入文件 ② 从而导入控制器 BindingMyController import 'package:flutter_getx_example/GetXBindingExample/controller/BindingMyController.dart'; // 引入文件 ③ 从而导入控制器 BindingHomeController import 'package:get/get.dart'; class AllControllerBinding implements Bindings { @override void dependencies() { // TODO: implement dependencies Get.lazyPut&lt;BindingMyController&gt;(() =&gt; BindingMyController()); // 启动控制器 Get.lazyPut&lt;BindingHomeController&gt;(() =&gt; BindingHomeController()); // 启动控制器 } } ② BindingHomeController.dart②和③文件都是定义控制器的，在上面文件中引入并启动 import 'package:get/get.dart'; class BindingHomeController extends GetxController { var count = 0.obs; void increment() { count++; } } ③ BindingMyController.dartimport 'package:get/get.dart'; class BindingMyController extends GetxController { var count = 0.obs; void increment() { count++; } } 我们的绑定文件就已经写好了，下面就要进行初始化，我们若要进行初始化，那么就要在项目启动的时候，在 GetMaterialApp() 里面使用参数 initialBinding 导入我们的实例化绑定类，如下所示： 在项目启动时进行初始化绑定④ main.dart在主文件中我们在 import 'package:flutter/material.dart'; import 'package:flutter_getx_example/GetXBindingExample/binding/AllControllerBinding.dart'; // 引入文件 ① 即绑定文件，里面实现了绑定类，我们需要引入并且使用绑定类 import 'package:flutter_getx_example/GetXBindingExample/GetXBindingExample.dart'; // 引入文件 ⑤，此文件里面有组件使用了控制器，我们引入就是为了使用这个组件 import 'package:get/get.dart'; void main() { runApp(MyApp()); } class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { /// GetX Binding return GetMaterialApp( title: \"GetX\", initialBinding: AllControllerBinding(), // 在这个地方我们初始化绑定 home: GetXBindingExample(), ); } } 初始化绑定后我们就可以在组件中使用控制器了。 路由绑定如果我们想绑定到指定路由内，我们可以在 getPages 配置项（上面已经提到过）里面在相应路由的 GetPage 方法内加上参数 binding，例如： 注意： 下面所说的 BHomeControllerBinding 其实就是控制器 BindingHomeController 的绑定类，与上面的 AllControllerBinding 不同的是，AllControllerBinding 是将两个控制器合并在一起的（dependencies() 方法里启动了两个控制器），而 BHomeControllerBinding 仅仅启动了 BindingHomeController，因此没啥太大区别。然而代码比较重复我就不再记录。 BHome 组件内容与 GetXBindingExample 组件内容大致一样，因为为了演示路由绑定，因此复制粘贴了一个 BHome 组件页面，唯一的区别就是没有那个转跳按钮。 getPages: [ GetPage( name: \"/home\", page: ()=&gt; const BHome(), binding: BHomeControllerBinding() // 值为绑定类实例 ) ] 此时运行是会报错的因为我们还没有对绑定类进行初始化，此时要在 main() 里面 runApp() 之前进行初始化： void main() { BMyControllerBinding().dependencies(); runApp(MyApp()); } 当然如果我们不想使用单独的绑定类，也可以绑定构建器，那么 binding 参数此时应该这样写（使用 BindingsBuilder() 方法）： binding: BindingsBuilder(() =&gt; { Get.lazyPut&lt;BindingHomeController&gt;(() =&gt; BindingHomeController()) }) 此时 main() 函数里面不需要再初始化控制器了。 在页面中使用状态管理器⑤ GetXBindingExample.dart此文件内包含 main.dart 文件中引入的组件 GetXBindingExample，在这个组件里我们使用控制器 BindingMyController，我们只需要引入这个类并且使用 Get.find() 例如 Get.find&lt;BindingMyController&gt;() 就可以使用该控制器。 在 BHome 组件里（没有展示代码）我们使用的不是 BindingMyController 而是 BindingHomeController 是为了演示路由绑定。 import 'package:flutter/material.dart'; import 'package:flutter_getx_example/GetXBindingExample/BHome.dart'; // 这个文件是一个页面组件，我们下面要使用路由转跳绑定进行演示 注释1（见下面使用例子里的解释） import 'package:flutter_getx_example/GetXBindingExample/binding/BHomeControllerBinding.dart'; // 这个文件里面 BHome 页面组件使用的绑定类，我们在不使用声明式路由的时候在参数中使用绑定需要使用绑定类 注释1（见下面使用例子里的解释） import 'package:flutter_getx_example/GetXBindingExample/controller/BindingMyController.dart'; // 引入文件 ③，即我们想使用的控制器 import 'package:get/get.dart'; class GetXBindingExample extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"GetXBinding\"), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Obx(() =&gt; Text( // 我们可以直接通过 Get.find() 来查找并使用我们的控制器 \"计数器的值为 ${Get.find&lt;BindingMyController&gt;().count}\", style: TextStyle(color: Colors.red, fontSize: 30), )), SizedBox(height: 20,), ElevatedButton( onPressed: () { Get.find&lt;BindingMyController&gt;().increment(); }, child: Text(\"点击加1\") ), SizedBox(height: 20,), ElevatedButton( onPressed: () { // 没有绑定进入页面，则点击加1没有效果 Get.to(BHome()); // 若在声明式路由 即 getPages 里面配置了绑定，那么使用声明式路由转跳会使用控制器，点击加1是有效果的 // Get.toNamed(\"/bHome\"); // 若不使用声明式路由并且想要使用绑定，需要添加参数 binding，值为绑定类实例 // 注释1：若不使用这种方式，注释1引入的两个文件都不需要引入了。 // Get.to(BHome(), binding: BHomeControllerBinding()); }, child: Text(\"跳转去 Home 页\") ), ], ), ), ); } } 将服务器获取的数据转为类型，可以使用这个网站：Instantly parse JSON in any language | quicktype 只需要把数据粘贴到左侧右侧选择相应的语言就可以生成。 GetUtilsGetUtils 是 getx 为我们提供一些常用的工具类库，包括值是否为空、是否是数字、是否是视频、图片、音频、PPT、Word、APK、邮箱、手机号码、日期、MD5、SHA1等等。 以判断是否是邮箱、手机号、IPV4地址为例： import 'package:flutter/material.dart'; import 'package:get/get.dart'; class GetXUtilsExample extends StatelessWidget { var textFieldController = TextEditingController(); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(\"GetX Utils\"), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Padding( padding: EdgeInsets.all(20), child: TextField( controller: textFieldController, ), ), SizedBox(height: 10,), Padding( padding: EdgeInsets.all(10), child: ElevatedButton( child: Text(\"判断是否是邮箱\"), onPressed: () async { if (GetUtils.isEmail(textFieldController.text)) { Get.snackbar(\"正确\", \"恭喜你, 完全正确\", backgroundColor: Colors.greenAccent); } else { Get.snackbar( \"邮箱错误\", \"请输入正确的邮箱\", backgroundColor: Colors.pink ); } }, ), ), Padding( padding: EdgeInsets.all(10), child: ElevatedButton( child: Text(\"判断是否是手机号\"), onPressed: () async { if (GetUtils.isPhoneNumber(textFieldController.text)) { Get.snackbar(\"正确\", \"恭喜你, 完全正确\", backgroundColor: Colors.greenAccent); } else { Get.snackbar( \"手机号错误\", \"请输入正确的手机号\", backgroundColor: Colors.pink ); } }, ), ), Padding( padding: EdgeInsets.all(10), child: ElevatedButton( child: Text(\"判断是否是IPv4\"), onPressed: () async { if (GetUtils.isIPv4(textFieldController.text)) { Get.snackbar(\"正确\", \"恭喜你, 完全正确\", backgroundColor: Colors.greenAccent); } else { Get.snackbar( \"地址错误\", \"请输入正确的IPv4地址\", backgroundColor: Colors.pink ); } }, ), ), ], ), ), ); } } GetUtils 有以下方法（转自文档）： 属性 hashCode → int The hash code for this object.read-onlyinherited runtimeType → Type A representation of the runtime type of the object.read-onlyinherited 方法 noSuchMethod(Invocation invocation) → dynamic Invoked when a nonexistent method or property is accessed.inherited toString() → String A string representation of this object.inherited Operators operator ==(Object other) → bool The equality operator.inherited 静态方法 camelCase(String value) → String? 用于将短句子或者短语转为驼峰字符串 Example: your name =&gt; yourName capitalize(String value) → String? 将每个单词首字母大写 Example: your name =&gt; Your Name capitalizeFirst(String s) → String? 将第一个单词首字母大写 Example: your name =&gt; Your name createPath(String path, [Iterable? segments]) → String hasCapitalletter(String s) → bool 检查字符串中是否含有大写字母 hasMatch(String? value, String pattern) → bool isAlphabetOnly(String s) → bool 检查字符串是否仅由字母组成。 (不包含空格) isAPK(String filePath) → bool 检查路径地址是否为 APK 文件地址 (判断字符串结尾是不是 .apk) isAudio(String filePath) → bool 检查路径地址是否为音频文件地址 (判断字符串结尾是不是常见的音频格式) isBinary(String s) → bool 检查字符是否为二进制 isBlank(dynamic value) → bool? 检查数据是否为纯空格组成或者空白字符串 isBool(String value) → bool 检查字符串是否为布尔（true 或 false） isCaseInsensitiveContains(String a, String b) → bool 检查字符串 a 中是否包含字符串 b (不区分大小写) isCaseInsensitiveContainsAny(String a, String b) → bool 检查字符串 a 中是否包含字符串 b 或字符串 b 中是否包含字符串 a (不区分大小写) isChm(String filePath) → bool 检查路径地址是否为 chm 文件地址 isCnpj(String cnpj) → bool isCpf(String cpf) → bool 检查字符串是否为有效 cpf isCurrency(String s) → bool 检查字符串是否为货币 isDateTime(String s) → bool 检查字符串是否为时间戳 (UTC or Iso8601) isEmail(String s) → bool 检查字符串是否为邮箱格式 isEqual(num a, num b) → bool 检查两个数字是否相等 isExcel(String filePath) → bool 检查路径地址是否为 Excel 文件地址 isGreaterThan(num a, num b) → bool 比较数字 a 是否大于数字 b isHexadecimal(String s) → bool 检查字符串是否为十六进制 Example: HexColor =&gt; #12F isHTML(String filePath) → bool 检查路径地址是否为 HTML 文件地址 isImage(String filePath) → bool 检查路径地址是否为图片文件地址 isIPv4(String s) → bool 检查字符串是否为 IPv4 地址 isIPv6(String s) → bool 检查字符串是否为 IPv6 地址 isLengthBetween(dynamic value, int minLength, int maxLength) → bool 检查数据长度是否在 minLength 到 maxLength 之间 isLengthEqualTo(dynamic value, int otherLength) → bool 检查数据长度是否等于 otherLength isLengthGreaterOrEqual(dynamic value, int maxLength) → bool 检查数据长度是否大于或等于 maxLength isLengthGreaterThan(dynamic value, int maxLength) → bool 检查数据长度是否大于 maxLength isLengthLessOrEqual(dynamic value, int maxLength) → bool 检查数据长度是否小于或等于 maxLength isLengthLessThan(dynamic value, int maxLength) → bool 检查数据长度是否小于 maxLength isLengthLowerOrEqual(dynamic value, int maxLength) → bool 检查数据长度是否小于或等于 maxLength （方法废除，用 isLengthLessOrEqual 代替） isLengthLowerThan(dynamic value, int maxLength) → bool 检查数据长度是否小于 maxLength（方法废除，用 isLengthLessThan 代替） isLowerThan(num a, num b) → bool 检查数字 a 是否小于数字 b isMD5(String s) → bool 检查字符串是否为 MD5 isNull(dynamic value) → bool 检查数据是否为空 null isNullOrBlank(dynamic value) → bool? 检查数据是否为 null 或者空白 (为空或者仅由空格组成) isNum(String value) → bool 检查字符串是否是否符合整型或者浮点型格式 isNumericOnly(String s) → bool 检查字符串是否只包含数字。数字不包含”.“。 isOneAKind(dynamic value) → bool 检查所有数据是否具有相同的值 Example: 111111 -&gt; true, wwwww -&gt; true, 1,1,1,1 -&gt; true isPalindrom(String string) → bool 检查字符串是否为 Palindrom isPassport(String s) → bool 检查字符串是否为护照号码 isPDF(String filePath) → bool 检查路径地址是否为 PDF 文件地址 isPhoneNumber(String s) → bool 检查字符串是否为手机号格式 isPPT(String filePath) → bool 检查路径地址是否为 PPT 文件地址 isSHA1(String s) → bool 检查字符串是否为 SHA1 isSHA256(String s) → bool 检查字符串是否为 SHA256 isSSN(String s) → bool 检查字符串是否为SSN（社会安全号） isTxt(String filePath) → bool 检查路径地址是否为文本文件地址 isURL(String s) → bool 检查字符串是否为网址格式 isUsername(String s) → bool 检查字符串是否为有效的用户名 isVector(String filePath) → bool 检查路径地址是否为 vector 文件地址 isVideo(String filePath) → bool 检查路径地址是否为视频文件地址 isWord(String filePath) → bool 检查路径地址是否为 Word 文件地址 nil(dynamic s) → dynamic In dart2js (in flutter v1.17) a var by default is undefined. Use this only if you are in version &lt;- 1.17. So we assure the null type in json convertions to avoid the “value”:value==null?null:value; someVar.nil will force the null type if the var is null or undefined. nil taken from ObjC just to have a shorter sintax. numericOnly(String s, {bool firstWordOnly = false}) → String 提取字符串中的数字 Example: OTP 12312 27/04/2020 =&gt; 1231227042020 如果 firstWordOnly 为 true，那么返回示例 “12312”（第一个找到的数字单词） paramCase(String? text) → String? 将短语或短句子用 - 连接 printFunction(String prefix, dynamic value, String info, {bool isError = false}) → void removeAllWhitespace(String value) → String 删掉所有空格 Example: your name =&gt; yourname snakeCase(String? text, {String separator = ‘_’}) → String? 将短语或短句子用 _ 连接 GetViewGetView 只是对已注册的 Controller 有一个名为 controller 的 getter 的 const Stateless 的Widget，如果我们只有单个控制器作为依赖项，那我们就可以使用 GetView ，而不是使用 StatelessWidget ，并且避免了写 Get.Find()。 GetView 的使用方法非常简单，只是要将视图层继承自 GetView 并传入需要注册的控制器并 Get.put() 即可，例如如下组件： import 'package:flutter/material.dart'; import 'package:flutter_getx_example/GetViewAndGetWidgetExample/GetViewCountController.dart'; import 'package:get/get.dart'; // 我们仅需要继承 GetView class GetViewAndGetWidgetExample extends GetView&lt;GetViewCountController&gt; { @override Widget build(BuildContext context) { Get.put(GetViewCountController()); return Scaffold( appBar: AppBar( title: Text(\"GetX GetView\"), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Obx(() =&gt; Text( \"count的值为: ${controller?.count}\", style: TextStyle( color: Colors.red, fontSize: 30 ), )), SizedBox(height: 20,), ElevatedButton( onPressed: () { controller.increment(); }, child: Text(\"点我加1\")) ], ), ), ); } } GetWidget它 “缓存 “了一个 Controller，由于 _cache_ ，不能成为一个 “const Stateless”。当我们使用Get.create(()=&gt;Controller()) 会在每次调用时生成一个新的Controller Get.find() import 'package:flutter/material.dart'; import 'package:flutter_getx_example/GetViewAndGetWidgetExample/GetViewCountController.dart'; import 'package:get/get.dart'; class GetViewAndGetWidgetExample extends GetWidget&lt;GetViewCountController&gt; { @override Widget build(BuildContext context) { Get.create(() =&gt; GetViewCountController()); return Scaffold( appBar: AppBar( title: Text(\"GetX GetView\"), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, crossAxisAlignment: CrossAxisAlignment.center, children: [ Obx(() =&gt; Text( \"count的值为: ${controller?.count}\", style: TextStyle( color: Colors.red, fontSize: 30 ), )), SizedBox(height: 20,), ElevatedButton( onPressed: () { controller.increment(); }, child: Text(\"点我加1\")) ], ), ), ); } } 在我们平时的开发过程中基本上很少会用到 GetWidget，因为我们在大部分情况下都不需要缓存 Controller。 当我们的页面中只依赖了一个控制器的情况话，那么使用 GetView 将是很好的选择，因为他大大简化了我们的代码。 Cli 脚手架Cli 脚手架能够让我们通过命令实现项目的创建、页面的创建等，一行命令就能实现复杂的操作。 安装 Cli 脚手架通过命令安装： flutter pub global activate get_cli 安装成功将看到如下结果： 设置环境变量安装好后看到命令行 Warning 字段有提示，让我们添加环境变量，我们根据提示添加环境变量即可。 Windows 可以直接在设置系统环境变量里面在 path 字段添加即可，MacOS、Linux 需要在根目录的 .bash_profile 文件添加如下行： #getX export PATH=\"$PATH\":\"$HOME/.pub-cache/bin\" 然后通过 source 加上路径，对环境变量生效（自行操作）。 校验是否安装成功我们通过 get 命令，看能不能打印如下，如果有，那么就表示安装成功了。（需要关闭之前的命令行，重新打开一个） Cli 创建工程我们可以通过 get create project 来进行创建工程： get create project 然后出现如下提示，我们选择创建Flutter Project 选择之后需要输入工程名称、公司域名、选择iOS语言、选择Android语言、是否空安全、是否校验，选完知道就会为我们开始创建工程。 若 flutter 以及 dart 版本过高可能没有 dart migrate 命令，若我们选择空安全会出现如下报错： 此时我们进入到新建的项目目录，然后执行以下指令： get init 然后选择第一个： 等待执行完毕即可。 目前不知道还有没有其他解决方法。 此时我们可以打开我们的项目文件。若使用 Android Studio 打开项目文件会发现文件列表仅显示两个文件夹并且文件内容不是我们的主文件内容，此时我们点击左上角的选项（Android），选择 project： 然后就会转到我们的项目文件夹，展开找到 lib 文件夹，里面就是我们写代码的文件了。 接下来我们就可以使用 GetCli 创建页面、路由、控制器等。 Cli 创建页面在我们使用 get init 命令的时候我们已经选择了目录结构，我们可以根据我们选择的结构进行下面指令的使用 第一种：Getx_pattern我们可以通过 get create page:&lt;页面名称&gt; 来快速创建一个页面，这个页面有 controller 、 view 、 binding 、 routes 等配置，结构是 Getx_pattern ： 第二种：CLEAN我们可以通过 get create screen:&lt;页面名称&gt; 来快速创建一个页面，这个页面有 controller 、 view 、 binding 、 routes 等配置，结构是 CLEAN： Cli 创建控制器我们可以通过 get create controller:&lt;控制器名称&gt; 来快速为已存在的 page 进行创建 controller ，并且他还重新了 controller 的生命周期以及初始化方法。要想绑定页面，需要在命令后面添加 on 参数： Cli 创建 View如果我们只是想单独创建一个 View，那我们可以通过 get create view:&lt;view名称&gt; on &lt;页面名称&gt; 来进行创建： Cli 创建 Provider如果我们需要创建 GetConnect ，那我们可以通过 get create provider:blogin on login 来进行创建。 get create provider:blogin on login Cli创建国际化如果我们需要对应用进行国际化配置，那我们可以通过 get generate locales assets/locales 来进行创建。 首先在 assets/locales 目录创建 json 格式的语言文件： zh_CN.json { \"buttons\": { \"login\": \"登录\", \"sign_in\": \"注册\", \"logout\": \"注销\", \"sign_in_fb\": \"用 Facebook 登录\", \"sign_in_google\": \"用 Google 登录\", \"sign_in_apple\": \"用 Apple 登录\" } } en_US.json { \"buttons\": { \"login\": \"Login\", \"sign_in\": \"Sign-in\", \"logout\": \"Logout\", \"sign_in_fb\": \"Sign-in with Facebook\", \"sign_in_google\": \"Sign-in with Google\", \"sign_in_apple\": \"Sign-in with Apple\" } } 运行 : get generate locales assets/locales 现在只需要在 GetMaterialApp 中加入 GetMaterialApp( ... translationsKeys: AppTranslation.translations, ... ) Cli 通过json生成模型第一种：不仅创建模型类，还会提供Provider如果我们需要对某个json文件生成模型，那我们可以通过get generate model on home with assets/models/user.json来进行生成 get generate model on home with assets/models/user.json ✓ File: user_model.dart created successfully at path: ./lib/app/modules/home/user_model.dart ✓ File: user_provider.dart created successfully at path: ./lib/app/modules/home/providers/user_provider.dart Time: 499 Milliseconds 第二种：只生成模型类get generate model on login with assets/models/user.json --skipProvider ✓ File: user_model.dart created successfully at path: ./lib/app/modules/login/user_model.dart Time: 408 Milliseconds 第三种：通过连接生成模型类get generate model on home from \"https://api.github.com/users/CpdnCristiano\" ? Could not set the model name automatically, which name do you want to use? githubHome ✓ File: github_home_model.dart created successfully at path: ./lib/app/modules/home/github_home_model.dart ✓ File: github_home_provider.dart created successfully at path: ./lib/app/modules/home/providers/github_home_provider.dart Time: 14033 Milliseconds Cli 安装包（dependencies)第一种：直接安装最新版本get install dio Installing package \"dio\" … ✓ 'Package: dio installed! Running `flutter pub get` … $ flutter pub get Running \"flutter pub get\" in getx_example... 2,656ms Time: 5815 Milliseconds 第二种：同时安装多个包get install path dio Installing package \"path\" … ✓ 'Package: path installed! Installing package \"dio\" … ✓ 'Package: dio installed! Running `flutter pub get` … $ flutter pub get Running \"flutter pub get\" in getx_example... 732ms Time: 7146 Milliseconds 第三种：安装自定版本的包get install prodiver:5.0.0 Installing package \"prodiver\" … ✓ 'Package: prodiver installed! Cli安装包（dev_dependencies)我们可以通过 get install flutter_launcher_icons --dev 安装开发时所依赖的包 get install flutter_launcher_icons --dev The [--dev] is not necessary Installing package \"flutter_launcher_icons\" … ✓ 'Package: flutter_launcher_icons installed! Cli卸载包第一种：卸载某个安装包get remove http Removing package: \"http\" Package: http is not installed in this application Running `flutter pub get` … $ flutter pub get Running \"flutter pub get\" in getx_example... 772ms Time: 2641 Milliseconds 第二种：同时卸载多个包get remove dio path Removing package: \"dio\" ✓ Package: dio removed! Removing package: \"path\" ✓ Package: path removed! Running `flutter pub get` … $ flutter pub get Running \"flutter pub get\" in getx_example... 1,085ms Time: 3142 Milliseconds Cli 更新脚手架我们可以通过get update对脚手架进行更新 get update Latest version of get_cli already installed Time: 3315 Milliseconds Cli查看版本号我们可以通过get -v 查看当前脚手架的版本号 get -v ░██████╗░███████╗████████╗ ░█████╗░██╗░░░░░░██╗ ██╔════╝░██╔════╝╚══██╔══╝ ██╔══██╗██║░░░░░░██║ ██║░░██╗░█████╗░░░░░██║░░░ ██║░░╚═╝██║░░░░░░██║ ██║░░╚██╗██╔══╝░░░░░██║░░░ ██║░░██╗██║░░░░░░██║ ╚██████╔╝███████╗░░░██║░░░ ╚█████╔╝███████╗ ██║ ░╚═════╝░╚══════╝░░░╚═╝░░░ ░╚════╝░╚══════╝ ╚═╝ Version: 1.6.0 Time: 148 Milliseconds Cli帮助当我们忘记了命令的使用方式，我们可以通过get help进行查看帮助。 get help List available commands: create: controller: Generate controller page: Use to generate pages project: Use to generate new project provider: Create a new Provider screen: Generate new screen view: Generate view generate: locales: Generate translation file from json files model: generate Class model from json help: Show this help init: generate the chosen structure on an existing project: install: Use to install a package in your project (dependencies): remove: Use to remove a package in your project (dependencies): sort: Sort imports and format dart files update: To update GET_CLI --version: Shows the current CLI version' Time: 94 Milliseconds StateMixin Flutter 中一种更新 UI 的方式是使用 StateMixin，StateMixin 是多种状态的混合 因为 Controller 是负责处理数据和业务功能的，在 Controller 的后面使用 with StateMixin StateMixin&lt;T&gt; 中T是数据模型，比如 User ，StateMixin&lt;User&gt; 当数据模型的数据改变时(如：空/完成/出错等)时，调用 change(data, status); 方法 RxStatus中的状态RxStatus.loading(); RxStatus.loadingMore() RxStatus.success(); RxStatus.empty(); RxStatus.error('message'); StateMixin使用示例main.dart： 主要配置 APP 显示 Home： import 'package:flutter/material.dart'; import 'package:get/get.dart'; import 'package:getx_sample/views/Home.dart'; void main() =&gt; runApp(GetMaterialApp(home: Home())); Home.dart： 引入 Controller 并使用： import 'package:flutter/material.dart'; import 'package:get/get.dart'; import 'package:getx_sample/views/OtherClass.dart'; // 显示页面（下面通过 Get.to 转跳） import '../controller/Controller.dart'; class Home extends StatelessWidget { @override Widget build(context) { //通过Get.put()方法初始化Controller final Controller c = Get.put(Controller()); return Scaffold( //当count变化时，Obx可以监听改变 appBar: AppBar(title: Obx(() =&gt; Text(\"Clicks: ${c.count}\"))), //通过Get.to方法取代Navigator.push代替页面间的跳转 body: Center(child: ElevatedButton( child: Text(\"Go to Other\"), onPressed: () =&gt; Get.to(OtherClass()))), floatingActionButton: FloatingActionButton(child: Icon(Icons.add), onPressed: c.increment)); } } user.dart：实体类 class User { User({this.name = '', this.age = 0}); String name; int age; } Controller.dart：控制器 import 'package:get/get.dart'; import 'package:getx_sample/bean/User.dart'; // 实体类（即类型） class Controller extends GetxController with StateMixin&lt;User&gt; { // 继承 StateMixin var count = 0.obs; increment() =&gt; interval(count++, (_) =&gt; print(\"interval $_\"), time: Duration(seconds: 1)); changeLoading() { change(User(name: '1',age: 18), status: RxStatus.loading()); } changeSuccess() { change(User(name: 'Success',age: 20), status: RxStatus.success()); } changeEmpty() { change(User(name: '4',age: 21), status: RxStatus.empty()); } changeError() { change(User(name: '5',age: 22), status: RxStatus.error('error')); } } OtherClass.dart：显示页面，StateMixin 更新UI import 'package:flutter/cupertino.dart'; import 'package:flutter/material.dart'; import 'package:get/get.dart'; import 'package:get/get_state_manager/get_state_manager.dart'; import '../controller/Controller.dart'; class OtherClass extends GetView&lt;Controller&gt; { @override Widget build(BuildContext context) { return Scaffold( body: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Center( child:controller.obx( (state) =&gt; Text(state!.name), onLoading: const CupertinoActivityIndicator(radius: 10), //加载中，默认是个Center(child:CircularProgressIndicator()) onEmpty: const Text('No data found'), //空数据显示 onError: (error) =&gt; Text(error!), //出错界面显示 ) ), RaisedButton(child: Text(\"Loading\"), onPressed: () {controller.changeLoading();},),//TextButton文字 RaisedButton(child: Text(\"Success\"), onPressed: () {controller.changeSuccess();},),//TextButton文字 RaisedButton(child: Text(\"Empty\"), onPressed: () {controller.changeEmpty();},),//TextButton文字 RaisedButton(child: Text(\"Error\"), onPressed: () {controller.changeError();},),//TextButton文字 ], ) ); } } GetConnect GetX提供一种简便的网络请求方式：GetConnect 该请求方式支持：Rest API 的 GET/POST/PUT/DELETE/SOCKET 及 websocket 通信 支持自定义配置：请求拦截，响应拦截，Authen 认证等 定义 ProviderBaseProvider这个与我们使用 axios 创建网络请求类似，我们通常封装一个带有 baseURL 以及认证的请求拦截器，我们在定义其他的 GetConnect 的时候通常会继承一个 BaseProvider（用于拦截请求进行封装等）： class BaseProvider extends GetConnect { @override void onInit() { httpClient.baseUrl = SERVER_API_URL; // 请求拦截 httpClient.addRequestModifier&lt;void&gt;((request) { request.headers['Authorization'] = 'xxxxxx'; // 添加认证信息 return request; }); // 响应拦截 httpClient.addResponseModifier((request, response) { return response; }); } } 上面代码中 SERVER_API_URL 为我们服务器 API 地址。 其他 Provider例如我们做一个列表请求： class ArticleProvider extends BaseProvider { Future&lt;Response&gt; GetArticles(int id) =&gt; get('/articles/$id'); } 在控制器里进行使用class ArticleController extends GetxController with StateMixin&lt;Article&gt;{ // 寻找 Provider final ArticleProvider articles = Get.find(); void getArticle() async { //刚开始显示加载中 change(null,status: RxStatus.loading()); //执行网络请求（Provider 中的 GetArticles(id) 方法 Response response = await articles.GetArticles(0); //请求出错时 if(response.hasError){ change(null,status: RxStatus.error('Error')); }else{ //请求成功时，显示数据 Article article = Article.fromJson(response.body); change(article,status: RxStatus.success()); } } @override void onInit() { super.onInit(); //初始化时请求数据 getArticle(); } } 此处使用了 StateMixin，请求前显示加载中，根据请求情况显示成功和失败结果 Article：为数据类(自定义解析，不再列出，我们可以通过上面的 GetCli 的方法将返回的结果生成数据类) onInit：在程序初始化时，执行 getArticle 方法，请求网络数据 使用 change 方法执行状态改变 数据显示（在组件中）class ArticleWidget extends GetView&lt;ArticleController&gt;{ @override Widget build(BuildContext context) { return _buildMixState(); } Widget _buildMixState(){ return controller.obx( (data) =&gt; ListView.separated( itemCount: data!.data!.datas.length, separatorBuilder: (context, index) { return Divider(height: 10, color: Colors.grey); }, itemBuilder: (BuildContext context, int index) { return Column( children: [ Text(data.data!.datas[index].author), Text(data.data!.datas[index].title), Text(data.data!.datas[index].niceShareDate) ], ); }, ), onLoading: const CupertinoActivityIndicator(radius: 10), //加载中，默认是个Center(child:CircularProgressIndicator()) onEmpty: const Text('No data found'), //空数据显示 onError: (error) =&gt; Text(error!), //出错界面显示 ); } } 结束寥寥草草地结束。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.bietiaop.com/categories/Flutter/"},{"name":"前端","slug":"Flutter/前端","permalink":"https://blog.bietiaop.com/categories/Flutter/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://blog.bietiaop.com/tags/Flutter/"},{"name":"GetX","slug":"GetX","permalink":"https://blog.bietiaop.com/tags/GetX/"},{"name":"安卓应用开发","slug":"安卓应用开发","permalink":"https://blog.bietiaop.com/tags/%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"Android应用开发","slug":"Android应用开发","permalink":"https://blog.bietiaop.com/tags/Android%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"iOS应用开发","slug":"iOS应用开发","permalink":"https://blog.bietiaop.com/tags/iOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Hexo博客搭建","slug":"web/front/hexo/搭建hexo博客","date":"2023-07-01T17:54:40.000Z","updated":"2023-07-01T17:54:40.000Z","comments":true,"path":"2023/07/02/web/front/hexo/da-jian-hexo-bo-ke/","link":"","permalink":"https://blog.bietiaop.com/2023/07/02/web/front/hexo/da-jian-hexo-bo-ke/","excerpt":"","text":"前提面向低基础的同学的教程。给学弟学妹们看的。 NodeJS 环境安装搭建 Hexo 博客需要 NodeJS 环境。 什么是环境？（如果你的时间很宝贵，或者你有基础，可以直接跳过解释）一言以蔽之，即你的作品运行起来需要的“软件”。 这种软件比较特殊，一般来说是没有“图形化”界面的，但是会在你看不到的地方为你默默付出，把你写的东西经过它的处理变成计算机或者其他软件能够识别的文件。 我们编写 Hexo 博客，就需要一种环境，让我们写的东西变成浏览器能够认识的网页文件。 因此我们首先要搭建好 NodeJS 环境。 你可以去正规途径搜索 NodeJS 并下载，不过建议去 NodeJS 的官网下载安装：NodeJS官网。 官网页面给了两种版本下载：LTS长期维护版和尝鲜版，如果你后期不打算接触 NodeJS 学习的话，选择哪个版本都是可以的。这里以最新版作为教程。 下载后按照默认指引安装即可（安装位置可以自定义）。如果是 MacOS 或者 Linux 的话可能安装方法有些许不同，按照官方给的安装方法进行安装。 检验安装完之后我们要检验我们的 NodeJS 是否安装成功。 如果你的电脑系统是 Windows，按下键盘上的 ⊞Windows 和 R 键，打开一个如下的运行窗口： 在输入框内输入 cmd 并且点击确定或者回车，会打开一个命令行窗口，如下图所示： 如果你的电脑系统是 Linux 或者 MacOS，打开终端软件即可。 如果是其他系统，在安装完之后打开相应的终端软件。 打开终端（命令行）后，输入 node -v，按下回车，接着输入 npm -v，按下回车，如果安装成功将会显示 node 和 npm 的版本号： Hexo 环境在安装完 NodeJS 之后，通过 NodeJS 安装 Hexo 依赖，运行以下命令： npm install hexo-cli -g 安装完成后我们可以通过 Hexo Cli 工具进行博客项目的指令创建。 验证安装与验证 NodeJS 是否安装成功类似，执行 npx hexo -v，如果显示一大堆东西加上各自的版本号，说明安装成功。 特殊情况注意，如果你的 npm （NodeJS 包管理）安装命令安装依赖都很慢的话，可以尝试修改安装镜像源（阿里或者清华），也可以使用 cnpm。 没有安装慢的问题可以跳过。 npm 设置镜像的方法（仅通过 npm 自带指令）通过命令配置镜像（淘宝，其他类似） npm config set registry https://registry.npmmirror.com/ 如果不确定镜像是否设置成功，可以执行如下命令查看已配置的镜像地址： npm config get registry 如果显示的为你设置的地址（这里为 https://registry.npmmirror.com/），那么就表示设置成功了。 如果想切回默认的镜像地址，将设置镜像指令的地址替换为 https://registry.npmjs.org 即可。 其他方法可以参考这篇文章：npm设置镜像的方法（包含切换国外国内镜像源） 注意，淘宝已经把 npm 镜像地址从 https://registry.npm.taobao.org 迁移到了 https://registry.npmmirror.com/，上面 CSDN 博客里提到的淘宝镜像已经过时。 新建博客项目首先新建一个文件夹用于存放项目文件，后面将通过指令来创建博客文件夹。 创建项目文件夹是为了养成良好的习惯，将自己的项目分类放进项目文件夹有利于我们后期快速定位到项目文件。 如果你已经有自己的项目文件夹，就需要在里面再新建一个文件夹了，我们打开项目文件夹，在文件夹处打开终端（命令行），如果你是 Linux 系统+GUI界面，可以通过鼠标右击，选择在当前文件夹打开终端，如果你是 Windows 系统，可以通过 cd 命令进入文件夹，但是有简洁的方法：在文件资源管理器地址栏输入 cmd 并回车： 就会在当前文件夹打开命令行（说法可能误导，其实是将命令行执行的目标文件夹转到当前文件夹） 打开命令行后运行以下命令（将博客文件夹名称替换成你想要的名称，不要带上尖括号，它会新建一个你指定名称的文件夹）： hexo init &lt;博客文件夹名称&gt; # 如果上面的命令提示未找到命令 hexo (通常是Linux系统)，那么执行如下指令： npx hexo init &lt;文件夹名称&gt; # 后面出现相同情况不再赘述 它会克隆一个 Github 仓库，因此速度取决于你连上 Github 的速度，如果失败多尝试即可。（因为国内连接 Github 是不稳定的）。如果你之前执行过 Hexo 的创建指令，在克隆仓库失败的时候会提示你使用本地的缓存，如下图所示： 接着你会发现原来的项目文件夹里面多了个刚刚创建的文件夹： 你可以进入这个文件夹再按照之前的方法在博客文件夹打开终端，也可以在刚刚的终端窗口执行指令进入文件夹，具体指令为： cd &lt;文件夹名&gt; 这样就进入到了博客文件夹。 至此，新建一个博客项目成功。 初始化博客环境我们创建完博客项目之后，需要初始化该项目的博客环境，在上面的博客文件夹的终端中执行以下命令： npm install # 如果你安装了 yarn，可以使用以下命令： yarn install 执行这个命令会初始化博客项目文件夹的博客环境： 如果没有报错就说明环境依赖全部安装成功。 尝试运行本地博客服务在初始化博客环境之后，我们可以尝试运行起来我们的博客服务器，看看是否安装成功，我们需要执行以下命令： hexo s 如果运行成功会出现以上提示，它会提醒你服务器地址为 http://localhost:4000/ 这个本地服务器地址。 此时在浏览器输入这个地址即可看到我们的博客。 “可能出现的问题” 端口占用 端口占用的话可以使用运行参数来指定端口，在运行命令后加上 --port=端口号 即可。 依赖不完整 再执行 npm install 安装依赖，确保没有报错（warn 可以忽略）。 至此，博客的基本搭建已经完成，下面将介绍进一步的使用，包括设置站点信息、撰写文章、修改主题。 撰写一篇简单的文章当我们运行起来博客的时候，发现首页展现的是一篇标题为”Hello World“的文章，这是由 Hexo 自动生成的一篇文章，我们可以先从修改这篇文章的内容开始入手。 首先我们要知道的是，我们的文章使用 Markdown 编写，Hexo 会帮我们把 Markdown 文件转为带样式格式的网页文件。而我们要编写的 Markdown 文件存放在 博客目录/source/_posts 文件夹下，而 source 文件夹存放的是静态文件。如何理解呢？ 我们可以认为 source 文件夹里面存放的就是网站文件，我们可以把一些浏览器能够识别的文件如图片、CSS、JS等放在该文件夹下，Hexo 处理时，不会对这些文件进行转义修改，而会原封不动地放到生成的网站文件夹内。 例如我有一个 background.png 文件放到了 source 文件夹下，生成博客网站文件时，background.png 会被放到生成的网站文件夹的根目录下。再如我有一个 custom.css 放到了 source/style/ 文件夹下，那么这个文件最终会被放到 生成的网站文件夹/style/custom.css。 因此，我们可以放一些我们需要的静态文件供我们使用，引用的路径用绝对路径，但是这个绝对路径的根目录是 source 文件夹。这一点非常有用，我们在后面可能会需要存放一些静态文件使用，如果你现在不理解没有问题，以后会遇到的。 但是在 source 文件夹内有一个比较特别的文件夹——_posts 文件夹，这个文件夹里面存放我们的博客内容，这个文件夹里面的 markdown 文件会被特殊处理，最后放到一定格式的帖子文件夹目录。 值得注意的是，source 文件夹内的所有 markdown 文件（特殊设置的除外）都会通过 Hexo 处理生成一定格式的网页文件，具体设置后面会提到。 如果以上文字你很难理解的话，不要着急，慢慢来，用到的时候自然会懂的，文字还是比较难以理解的。 我们首先尝试修改自动生成的 Hello World 文章，打开 _posts 文件夹，会发现里面有一个 Markdown 文件，文件名为 hello-world.md ，这个就是自动生成的文章了，我们打开它，看看里面的结构。对于 Markdown，可以去网上看一些基本教程，这个东西很简单的，看了就会。对于编写用的编辑器，我个人更倾向于 Typora。 使用 Typora 打开后会看到如下的预览页面： 内容与我们博客网页上的一致，但是样式有区别，因为这是 Typora 编辑器，它与 Hexo 没有半毛关系，跟你的记事本文本编辑器一样，只不过自带了一些功能和主题。 我们可以通过点击右下角第二个按钮 &lt;/&gt; 按钮查看原始内容： 可以看到非常标准的 Markdown 内容，最上面有三个横线，注意，这三个横线是成对出现的：第一行和第三行。 这对横线通常放在文件开头，横线里放的是这篇文章的配置，例如文章标题、封面、发布时间、修改时间、关键词、分类、标签等。具体后面会提到。我们现在的目标是修改内容，看看有什么变化。 这里我把二级标题“Quick Start”修改为“快速开始”： 我们切换回 Typora 的预览模式，可以发现 Typora 的预览已经生效： 现在我们回到刚刚的博客网页，刷新页面，发现博客内容也相应地修改了： 至此，赢！我们修改了 Hello World 文章，至少在内容编辑方面，我们已经学会了。 接下来就是新建一篇文章！ 上面提到了文章的配置写在一对的三个横线内，也就意味着我们可以自己新建一个 md 文件，将配置写在对应位置，然后下面再写文章内容，不就可以了吗？没错！你很聪明！这样是可行的！而且标题跟文件名没有关系，文件名只是对应的网页的目录地址，你的文章标题包括检索用的标题都是写在配置里的。你可以看看 Hello World 这篇文章，文件名是 hello-world.md，但是它在 md 文件夹里配置了 title 文章标题，因此你看到的是 Hello World 而非 hello-world，而当你点击网页上的这个标题的时候会跳转到文章页，此时浏览器目录地址变成了 hello-world： 至于前面的日期就是我前面说的 Hexo 给 _posts 文件夹里的 Markdown 文件的特殊处理。放在 _posts 文件夹外的markdown 仅仅转为网页文件，地址中的字符还是 markdown 的文件名。 了解了这些，我们就可以从 0 手动新建一篇文章，这样固然不错，但是 Hexo 给我们一个更简便的方法：使用指令新建文章 hexo new [layout] &lt;title&gt; 其中 layout 是可选配置，默认为 post，这个 layout 是布局的意思，你可以理解为使用模板。模板文件存放在与 source 文件夹同级的 scaffolds 文件夹内，默认有三个布局：draft、page、post。对应着三种模板：草稿、页面、文章，默认为文章。布局有什么用，后面会提到。 title 就是我们的文章标题了，我们在博客根目录运行这个指令，看看效果（注意：因为我们已经开启了本地服务器，占用了命令行，我们可以再打开一个，不冲突的）。 它会告诉我们文件存放的位置，我们可以打开文件看看内容： 文件默认给我们写了三个配置：标题、日期和标签。 我们可以修改这些配置，例如给这个文章两个标签： 这里面的配置也是用的 yaml 格式，先提一嘴，我们的博客配置文件为 _config.yml ，这个文件就是一个 yaml 文件，里面的内容遵循 yaml 格式，可以了解一下这种格式，方便我们写配置。 接着我们可以在文件里写点内容，看看效果： 写完之后保存，回到博客网页首页，刷新页面。 可以看到我们写的内容生效了，标题为 study，内容也是一样的，并且最下面还有两个我们配置的标签，这个标签的作用就类似于关键词可以检索使用。 除此之外，还有很多配置，具体可以参考：官方文档 - Front-matter | Hexo。 至此我们撰写博客就已经学会了，下面填坑，说说什么是布局（模板）。 拓展这里的模板就是字面意思的模板，模仿某个模板文件生成一个有着一定固定格式的文件，打开 scaffolds 文件夹，可以看到布局的模板文件，打开后发现里面只写了我们之前提到的文章配置，并且配置内容为双引号括起来的，这里面的内容叫做“变量”，我们使用指令创建文档的时候，这些变量会按照一定的格式被填充，比如说 {{ title }} 会被填充为我们的页面标题，{{ date }} 会被填充为创建时间。默认模板的说明可以参考官方文档：写作 | Hexo。 就如我之前提到的，我们可以在 source 文件夹下放一个 markdown 文件，并且这个文件会被生成网页文件，而且路径跟 _posts 文件夹下的不同，不会经过文章的特殊处理（例如加上日期路径），因此我们可以通过这种方式创建一个没有文章格式的单页面。当我们对这种页面需求多的时候，而且需要一种固定格式，此时我们就可以写一个布局（模板）文件，方便我们创建类似的页面。 对于写布局文件我就不多说了，在拓展里我说一说不被当做文章处理的 markdown 文件通常会被怎么使用。 首先我们在 source 文件夹下创建一个 about.md 文件，文件内容如下： 现在我们保存这个文件。没有感觉到什么变化。并且首页文章也不列出来这个文件。 不要着急，此时我们给路径加上 about.html。 可以看到，我们写的内容会被展示出来，但是并没有放到首页的文章列表里。这是因为它不被当做博客文章处理！ 而且路径跟之前提到的 Hello World 文章不同，这里并没有日期前缀路径。 好滴，这有啥用呢？我们可以通过这个创建几个子页面，可以是关于，可以是友情链接，可以是收藏夹等等。如果懂点前端，还可以自己写模板 HTML 文件，通过 layout 配置做出来一个突破这个文章样式的页面，比如说不显示那个 Hexo 等等。 值得一提的是，很多主题都带有这些功能，我们在使用主题的时候参考主题文档就可以实现了！我们无需重复造轮子。 配置博客当前博客内容并不是我们想要的，我们还没有配置博客站点名称，它默认是大大的 Hexo ！ 配置博客的文件在博客根目录的 _config.yml 文件里： 可以看到基本的配置，例如标题、副标题、简介、作者、语言等。 我们按需配置，这里不再赘述。配置详情参考：配置 | Hexo。 这里我以修改标题、副标题作为演示，我们将其修改为如下内容： 修改完成后我们需要重启本地服务器，在命令行按下 Ctrl + C 来停止当前服务。 然后再次执行启动服务，刷新页面。可以看到我们修改的配置生效了。 至于 description 简介，这是利于搜索引擎的，搜索引擎在检索后显示的网页简介。我们修改配置文件后一定要重启服务后刷新页面才能生效。 再提醒一次，详细配置请参考：配置 | Hexo 我们的 Hexo 博客的默认主题为 Landscape，每个主题都有自己的配置文件，因此你在 _config.yml 同一目录可以看到 _config.landscape.yml 的配置文件，这里是主题的配置，我们安装其他主题也用同样的方法进行配置。配置文件的命名规则为：_config.主题名.yml。具体的配置项要参考各个主题的文档。 页面发布我们可以使用指令生成网页文件，指令如下： hexo g 当执行这个指令，Hexo 就会生成网页文件，存放在博客目录下的 public 文件夹内，我们可以选择将这些文件放到我们的服务器或者静态页面托管平台上以启用我们的网站。 当然，对于类似于 GitHub Pages 的静态托管服务，Hexo 有一套完整的处理方案，方便我们使用。 配置 GitHub Pages官方对于配置 GitHub Pages 已经有了一个非常详细的教程说明：在 GitHub Pages 上部署 Hexo | Hexo 如果你仍有疑问可以评论或者联系我，我会出一个从创建 GitHub 账户到部署 GitHub Pages 的教程。 使用主题官方的默认主题我是看不惯的，我们可以使用其他主题，例如 Next、Sakura、Nexmoe等。这里我以 Nexmoe 为例，安装使用一个主题。 对于 Nexmoe，官方有说明文档：Hexo Theme Nexmoe | 🔥 一个比较特别的 Hexo 主题 目前 Nexmoe 4.0 版本文档不齐全，还需要参考 3.2 版本的文档：欢迎 | 🔥 A rather special Hexo theme (nexmoe.com) 按照主题文档，我们在博客根目录执行命令： npm install hexo-theme-nexmoe @nexmoe/hexo-renderer-inferno 执行后，修改 _config.yml，使用 Nexmoe 主题：在博客的根目录中编辑 _config.yml。将名为 theme 的键的值更改为 nexmoe。 此时，根目录缺少主题配置文件，我们可以参考官方仓库，创建一个 _config.nexmoe.yml。官方仓库地址：nexmoe/nexmoe.com (github.com) 找到官方仓库的 _config.nexmoe.yml 文件，复制内容到新建的主题配置文件，并且按照自己的情况修改配置内容。 修改完之后我们重启服务，预览效果。 部分为英文是因为配置文件里有语言选项，默认是英语，我没有修改，修改后可为中文。在 _config.yml 里找到 lanugage 选项，将内容修改为 zh-CN 即可。如果是 zh 的话会是繁体中文。 尽情享受你的记录博客之旅吧。 最后如果修改的配置等重启服务后不能及时生效，记得清理缓存，指令为： hexo clean 当然还有其他指令，具体移步：指令 | Hexo 安装插件方法非常简单，但是也因插件而异，如果需要啥插件，可以到搜索引擎搜索。 如果要记录博客，一定要坚持，博客不仅是记录自己的学习记录，更是自己的知识储备。我们难免会忘记一些知识，如果我们记录在了博客，下次遇到同样的问题可以直接翻找自己的博客，稍微看一下就能记起来了，我们肯定不能记住所有的东西，博客就是我们的第二大脑。 不仅如此，博客不仅会在必要的时候帮助自己还会帮助遇到同样问题的其他人。","categories":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.bietiaop.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://blog.bietiaop.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"blog","slug":"blog","permalink":"https://blog.bietiaop.com/tags/blog/"}]},{"title":"前端字体大小解决方案——字体切片","slug":"web/front/css/字体切割减少字体大小","date":"2023-06-29T02:30:15.000Z","updated":"2023-06-29T02:30:15.000Z","comments":true,"path":"2023/06/29/web/front/css/zi-ti-qie-ge-jian-shao-zi-ti-da-xiao/","link":"","permalink":"https://blog.bietiaop.com/2023/06/29/web/front/css/zi-ti-qie-ge-jian-shao-zi-ti-da-xiao/","excerpt":"","text":"前端字体文件过大问题在中文网站中，字体文件往往是最大的文件，每次请求网站都会下载字体文件，这样会导致网站加载速度变慢，影响用户体验。 在这方面，谷歌字体使用字体“切片”技术，将字体文件切割成多个小文件，使用 unicode-range 按需加载，这样可以减少字体文件的大小，提高网站加载速度。 unicode-rangeunicode-range 是 CSS3 中的一个属性，用于指定字体文件中包含的字符范围，浏览器会根据这个属性来判断是否需要下载字体文件。 unicode-range 属性的值可以是一个或多个范围，每个范围之间用逗号分隔，每个范围可以是一个或多个字符，每个字符之间用连字符分隔。 例如引入谷歌字体的 Noto Sans SC，可以使用以下代码： @font-face { font-family: 'Noto Sans SC'; font-style: normal; font-weight: 400; font-display: swap; src: url(https://fonts.gstatic.com/s/notosanssc/v12/k3kXo84MPvpLmixcA63oeALhLOCT-xWNm8Hqd37g1OkDRZe7lR4sg1IzSy-MNbE9VH8V.4.woff2) format('woff2'); unicode-range: U+1f1e9-1f1f5, U+1f1f7-1f1ff, U+1f21a, U+1f232, U+1f234-1f237, U+1f250-1f251, U+1f300, U+1f302-1f308, U+1f30a-1f311, U+1f315, U+1f319-1f320, U+1f324, U+1f327, U+1f32a, U+1f32c-1f32d, U+1f330-1f357, U+1f359-1f37e; } ... 字体切片字体切片是指将字体文件切割成多个小文件，每个文件包含不同的字符，这样可以减少字体文件的大小，提高网站加载速度。 谷歌采用机器学习等手段，将字体文件切割成多个小文件，每个文件包含不同的字符，这样的话，一般网页中使用到的中文也只是一部分字体，只需要加载多个资源包就能完全覆盖。就算网页中有很多生僻字，需要付出的代价也只是多加载几个资源包。 字体切片工具font-slice 将中文字体按照 Google Fonts 的切割子集方案，生成多个较小体积的资源包。仅需加载小部分字体资源即可展示完整页面。 字体切片使用安装npm install --save-dev font-slice # or yarn add -D font-slice 使用const fontSlice = require('font-slice'); const createFontSlice = require('font-slice'); createFontSlice({ // 字体文件 fontPath: path.resolve(__dirname, 'YourFont.ttf'), // 输出文件夹 outputDir: path.resolve(__dirname, './output'), }) 这是一个简单的使用示例。使用 NodeJS 运行此文件，即可在 ./output 文件夹中生成切片后的字体文件，同时有一个 CSS 文件，可直接调用 CSS 使用。 配置项declare type TOptions = { /** * 需要处理的源字体，暂只支持 ttf、otf (otf 也是先转成 ttf 再处理) */ fontPath: string; /** * 保存到的目录 */ outputDir: string; /** * 是否需要在生成完成后打开预览页面，默认为 true，如果为 false 不会生成 index.html 及启动服务器 */ preview?: boolean; /** * 生成字体文件的名称，默认为 `${fontFileName}.${index + 1}` */ generateFontSubsetName?: (fontFileName: string, index: number) =&gt; string; /** * 需要转换到的格式，默认为 [\"woff2\"] */ formats?: Array&lt;'woff' | 'woff2' | 'ttf' | 'eot' | 'svg'&gt;; /** * 字体的 font-family 值 */ fontFamily?: string; /** * 字体的 font-weight，默认为 normal */ fontWeight?: string; /** * 字体的 fontStyle，默认为 normal */ fontStyle?: string; /** * 字体的 font-display，默认为 swap */ fontDisplay?: string; /** * 自定义字体的分割格式，默认为 google fonts 的 unicode-range */ customUnicodeRange?: Array&lt;{ unicodes: number[]; }&gt;; /** * 如果开启可能会让生成的字体体积变大，默认不开启 * keep ttf hint info (fpgm, prep, cvt). default = false * https://github.com/ecomfe/fontmin#glyph */ hinting?: boolean; }; 参考中文字体的终极解决方案——对字体进行切片","categories":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.bietiaop.com/tags/CSS/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"网站","slug":"网站","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E7%AB%99/"},{"name":"网页","slug":"网页","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E9%A1%B5/"},{"name":"字体切割","slug":"字体切割","permalink":"https://blog.bietiaop.com/tags/%E5%AD%97%E4%BD%93%E5%88%87%E5%89%B2/"},{"name":"前端字体","slug":"前端字体","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%97%E4%BD%93/"}]},{"title":"Vite 使用 br 压缩","slug":"web/front/vite/vite使用br压缩","date":"2023-06-24T05:10:38.000Z","updated":"2023-06-24T05:10:38.000Z","comments":true,"path":"2023/06/24/web/front/vite/vite-shi-yong-br-ya-suo/","link":"","permalink":"https://blog.bietiaop.com/2023/06/24/web/front/vite/vite-shi-yong-br-ya-suo/","excerpt":"","text":"为什么使用 br 压缩 gzip 压缩Gzip 是一种用于文件压缩与解压缩的文件格式。它基于 Deflate 算法，可将文件（译者注：快速地、流式地）压缩地更小，从而实现更快的网络传输。Web 服务器与现代浏览器普遍地支持 Gzip，这意味着服务器可以在发送文件之前自动使用 Gzip 压缩文件，而浏览器可以在接收文件时自行解压缩文件。摘自：MDN Web Docs br 压缩同 gzip 类似， Brotli 也是一种压缩算法，由 Google 开发，对于文本压缩非常好。主要的特点就是它在服务器端和客户端都用到了词典，常见关键词和词组都有，这样可以获得更佳的压缩率。但 brotli 压缩速度比 Gzip 压缩慢，因此 gzip 可能更适合于压缩不可缓存的内容。 目前 Brotli已经获得各主流浏览器的支持。 gzip 与 br 压缩率对比根据某些文章的比较： JavaScript 文件用 Brotli 压缩可以比 gzip 的小 14%。HTML 文件会小 21%。CSS 文件会小 17% 参考：Brotli 压缩同 Gzip 压缩之比较 br 压缩的兼容性目前，br 压缩的兼容性并不是很好，但是随着时间的推移，br 压缩的兼容性会越来越好。具体兼容性表，请参见： Can I use brotli MDN Web Docs 除了浏览器的兼容性，还需要考虑服务器的兼容性，目前，nginx 1.16.0 以上版本支持 br 压缩，apache 2.4.26 以上版本支持 br 压缩。 Vite 使用 br 压缩 （vite-plugin-compression）1. 安装插件npm i -D vite-plugin-compression 2. 配置 vite.config.tsimport { defineConfig } from 'vite' import viteCompression from 'vite-plugin-compression' export default defineConfig({ plugins: [ // 其他插件 viteCompression({ verbose: true, disable: false, threshold: 10240, algorithm: 'brotliCompress', ext: '.br', }), ], }) Vite 开启 br 压缩 （rollup-plugin-brotli）1. 安装插件npm i -D rollup-plugin-brotli 2. 配置 vite.config.tsimport { defineConfig } from 'vite' import brotli from 'rollup-plugin-brotli' export default defineConfig({ plugins: [ // 其他插件 brotli(), ], }) Apache 开启 br 压缩1. 安装 brotli 模块sudo apt-get install brotli 2. 配置 Apache 安装 brotli 模块 sudo apt-get install brotli 配置 Apache 使用下面命令在 Apache 配置文件中启用 brotli 模块 sudo a2enmod brotli 之后，通过在虚拟主机配置文件中添加以下行来启用 brotli 压缩： &lt;IfModule mod_brotli.c&gt; AddOutputFilterByType BROTLI_COMPRESS text/html text/plain text/xml text/css text/javascript application/javascript application/x-javascript application/json application/xml application/rss+xml image/svg+xml &lt;/IfModule&gt; 保存文件并重新启动 Apache 服务器： sudo service apache2 restart 验证 Apache 是否开启 br 压缩 使用下面命令验证 Apache 是否开启 br 压缩 curl -I -H 'Accept-Encoding: br' http://your-domain.com 如果开启了 br 压缩，则会在返回信息中看到如下行： Content-Encoding: br 除了上面的方法，还可以参考如下教程： Apache压缩 Nginx 开启 br 压缩下载 Brotli 的源码；yum install git &amp;&amp; cd /usr/local/src git clone https://github.com/google/ngx_brotli.git pushd ngx_brotli git submodule update --init popd 执行命令 nginx -V，configure arguments 即为现有的参数；nginx version: nginx/1.16.1 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC) built with OpenSSL 1.1.1c 28 May 2019 TLS SNI support enabled configure arguments: --with-http_ssl_module --with-http_v2_module --with-http_sub_module --with-openssl=../openssl-1.1.1c 追加参数 --add-module=../ngx_brotli，重新编译 Nginx。本文中 Nginx 的源码目录是 /usr/local/src/nginx-1.16.1；cd nginx-1.16.1 ./configure \\ --with-http_ssl_module \\ --with-http_v2_module \\ --with-http_sub_module \\ --with-openssl=../openssl-1.1.1c \\ --add-module=../ngx_brotli make &amp;&amp; make install 如需执行平滑升级 (热部署)，make 之后请不要 make install： mv /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.old cp objs/nginx /usr/local/nginx/sbin/nginx make upgrade 接着修改 nginx.conf (默认值就够用。不妨再留意一下 gzip_types 和 brotli_types 指令，以允许压缩 text/html 以外的文件，MIME 类型列表见)；http { ... gzip on; brotli on; # gzip_types text/css text/javascript application/rss+xml; # brotli_types text/css text/javascript application/rss+xml; ... } 重载 Nginx，检验效果。nginx -t &amp;&amp; nginx -s reload 可以参考上文 验证 Apache 是否开启 br 压缩也可以可借由 Brotli Test 等工具，或者 Chrome DevTools 的 Network 面板，查看响应头中的 Content-Encoding 字段。","categories":[{"name":"Vite","slug":"Vite","permalink":"https://blog.bietiaop.com/categories/Vite/"},{"name":"前端","slug":"Vite/前端","permalink":"https://blog.bietiaop.com/categories/Vite/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"gzip","slug":"gzip","permalink":"https://blog.bietiaop.com/tags/gzip/"},{"name":"br","slug":"br","permalink":"https://blog.bietiaop.com/tags/br/"},{"name":"Vite","slug":"Vite","permalink":"https://blog.bietiaop.com/tags/Vite/"},{"name":"Vite插件","slug":"Vite插件","permalink":"https://blog.bietiaop.com/tags/Vite%E6%8F%92%E4%BB%B6/"},{"name":"压缩","slug":"压缩","permalink":"https://blog.bietiaop.com/tags/%E5%8E%8B%E7%BC%A9/"}]},{"title":"MySQL 查询语句优化","slug":"database/mysql/查询语句优化","date":"2023-06-23T14:30:15.000Z","updated":"2023-06-23T14:30:15.000Z","comments":true,"path":"2023/06/23/database/mysql/cha-xun-yu-ju-you-hua/","link":"","permalink":"https://blog.bietiaop.com/2023/06/23/database/mysql/cha-xun-yu-ju-you-hua/","excerpt":"","text":"避免使用 SELECT *SELECT * 会导致数据库扫描整张表，如果表中有很多字段，就会增加查询的复杂度和资源消耗，那么就会导致查询效率低下。 优化前SELECT * FROM `user` WHERE `age` &gt; 25; 优化后SELECT `id`, `name`, `age` FROM `user` WHERE `age` &gt; 25; 避免在 WHERE 子句中使用函数在 WHERE 子句中使用函数可能会导致 MySQL 中无法使用索引，从而降低查询性能。 优化前SELECT * FROM `user` WHERE YEAR(`created_at`) = 2021; 优化后SELECT * FROM `user` WHERE `created_at` BETWEEN '2021-01-01' AND '2021-12-31'; 这个例子中，使用 YEAR 函数将使 MySQL 无法使用 created_at 字段上的索引，而使用 BETWEEN 则可以使用索引并且提高查询性能。 使用 JOIN 时，使用 INNER JOIN 而不是 LEFT JOIN 或者 RIGHT JOIN，除非你确实需要。INNER JOIN 通常比 LEFT JOIN 和 RIGHT JOIN 更快，因为它只返回匹配的行，如果不需要返回非匹配的行，应该使用 INNER JOIN 以提高查询性能。 优化前SELECT * FROM `user` LEFT JOIN `user_info` ON `user`.`id` = `user_info`.`user_id`; 优化后SELECT * FROM `user` INNER JOIN `user_info` ON `user`.`id` = `user_info`.`user_id`; 使用 EXISTS 或 NOT EXISTS 代替 IN 或 NOT ININ 和 NOT IN 子句可能效率较低，尤其是在子查询中包含大量记录时，而 EXISTS 和 NOT EXISTS 子句则可以更好地处理这种情况，他们只需检查是否存在匹配的行，而不是返回所有匹配的行。 优化前SELECT * FROM `user` WHERE `id` IN (SELECT `user_id` FROM `user_info`); 优化后SELECT * FROM `user` WHERE EXISTS (SELECT 1 FROM `user_info` WHERE `user`.`id` = `user_info`.`user_id`); 如果数据量少，可以使用 IN 子句，如果数据量大，应该使用 EXISTS 子句。 避免在 WHERE 子句中使用 OR 运算符OR 运算符在 WHERE 子句中使用时，可能会导致 MySQL 无法使用索引，从而降低查询性能。 优化前SELECT * FROM `user` WHERE `age` = 25 OR `age` = 26; 优化后SELECT * FROM `user` WHERE `age` IN (25, 26); 在上面例子中，使用 IN 子句可以避免 OR 运算符并使用索引，从而提高查询性能。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.bietiaop.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"数据库/后端","permalink":"https://blog.bietiaop.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.bietiaop.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"https://blog.bietiaop.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"MySql","slug":"MySql","permalink":"https://blog.bietiaop.com/tags/MySql/"},{"name":"查询","slug":"查询","permalink":"https://blog.bietiaop.com/tags/%E6%9F%A5%E8%AF%A2/"},{"name":"Query","slug":"Query","permalink":"https://blog.bietiaop.com/tags/Query/"}]},{"title":"Redux的使用 - 以登录状态管理为例","slug":"web/front/react/Redux的使用","date":"2023-04-19T08:46:07.000Z","updated":"2023-04-19T08:46:07.000Z","comments":true,"path":"2023/04/19/web/front/react/redux-de-shi-yong/","link":"","permalink":"https://blog.bietiaop.com/2023/04/19/web/front/react/redux-de-shi-yong/","excerpt":"","text":"安装 Redux Tookit 和 React Reduxnpm install @reduxjs/toolkit react-redux -S 创建 store 相关文件在 src 目录下创建 store 文件夹，用于存放 Redux 和 store 相关文件。 在 src 目录下创建 hooks 文件夹，用于存放自定义 hooks，我们需要在里面创建一个 store.ts，文件里面存放 Redux 相关的 Hooks。 在 store 文件夹下创建 index.ts 文件，用于创建 Redux store。 这里面以登录状态管理为例，创建 login.ts 文件，用于存放登录状态相关的 reducer 和 action。 store/index.ts此文件是 Redux store 的入口文件，用于创建 Redux store。 通过 configureStore 方法创建 Redux store，通过 reducer 属性指定 reducer。 我们可以导入已创建的 reducer，然后通过 reducer 属性指定。 // src/store/index.ts import { configureStore } from '@reduxjs/toolkit' import loginReducer from './login' export const store = configureStore({ reducer: { login: loginReducer } }) // 从 store 本身推断出 `RootState` 和 `AppDispatch` 类型 export type RootState = ReturnType&lt;typeof store.getState&gt;; export type AppDispatch = typeof store.dispatch; 导出两个类型，RootState 和 AppDispatch，分别用于获取 store 的 state 和 dispatch 的类型，在 typescript 中使用防止因为数据类型而报错。 这样，我们就创建了 Redux store。 hooks/store.ts此文件用于存放 Redux 相关的 Hooks。 // src/hooks/store.ts import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux' import type { RootState, AppDispatch } from '../store' // 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector` // 使用泛型指定 state 的类型 export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector; // 指定 dispatch 的类型 export const useAppDispatch: () =&gt; AppDispatch = useDispatch; 使用 useAppSelector 和 useAppDispatch 来获取 store 的 state 和 dispatch。如果我们直接使用 useSelector 和 useDispatch，那么我们就需要在每次使用的时候都要指定 state 和 dispatch 的类型，这样就会很麻烦。这样我们在其他地方直接使用 useAppSelector 和 useAppDispatch 代替默认的 useSelector 和 useDispatch 来获取 state 和 dispatch。 store/login.ts此文件用于存放登录状态相关的 reducer 和 action。 通过 createSlice 方法创建 reducer，通过 reducers 属性指定 reducer。通过 actions 属性指定 action。 // src/store/login.ts import { createSlice, PayloadAction } from '@reduxjs/toolkit' import type { RootState } from \"../store\"; // state 类型 interface LoginState { isLogin: boolean } // 初始值 const initialState: LoginState = { isLogin: false } // 创建 slice const loginSlice = createSlice({ name: 'login', initialState, reducers: { login(state) { state.isLogin = true }, logout(state) { state.isLogin = false } } }) // 导出 action export const { login, logout } = loginSlice.actions // 导出 state // 选择器等其他代码可以使用导入的 `RootState` 类型 export const loginState = (state: RootState) =&gt; state.loginState; // 导出 reducer export default loginSlice.reducer 使用在 App.tsx 中使用。 // src/App.tsx // 导入 provider import { Provider } from 'react-redux' // 导入 store import { store } from './store' import { useAppSelector, useAppDispatch } from './hooks/store' import { login, logout } from './store/login' function App() { const isLogin = useAppSelector(state =&gt; state.login.isLogin) const dispatch = useAppDispatch() return ( &lt;div className=\"App\"&gt; &lt;button onClick={() =&gt; dispatch(login())}&gt;登录&lt;/button&gt; &lt;button onClick={() =&gt; dispatch(logout())}&gt;登出&lt;/button&gt; &lt;Provider store={store}&gt; &lt;p&gt;{isLogin ? '已登录' : '未登录'}&lt;/p&gt; &lt;/Provider&gt; &lt;/div&gt; ); } export default App;","categories":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"React","slug":"React","permalink":"https://blog.bietiaop.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://blog.bietiaop.com/tags/Redux/"}]},{"title":"图片投影阴影效果","slug":"web/front/css/图片投影阴影效果","date":"2023-04-15T13:00:33.000Z","updated":"2023-04-15T13:00:33.000Z","comments":true,"path":"2023/04/15/web/front/css/tu-pian-tou-ying-yin-ying-xiao-guo/","link":"","permalink":"https://blog.bietiaop.com/2023/04/15/web/front/css/tu-pian-tou-ying-yin-ying-xiao-guo/","excerpt":"","text":"原理使用 CSS 的 before 效果，将 background 设置为 inherit，复制一个一样的图片项。 使用 filter 滤镜将其模糊化，然后置于底层即可。 准备首先写一个列表，用来存放图片项，然后写几个图片项，用来展示图片，这里面图片要以背景的形式展示。 HTML： &lt;div class=\"list\"&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;div class=\"item\"&gt;&lt;/div&gt; &lt;/div&gt; CSS： * { margin: 0; padding: 0; box-sizing: border-box; } body { background-color: #ccc; } .list { width: 100%; display: flex; justify-content: center; padding: 100px 0; } .item { width: 200px; height: 200px; border: 1px solid #f00; /* 为了看清楚，这里设置了边框，后面会删掉 */ margin: 0 50px; border-radius: 30px; position: relative; } 效果： 现在，大体的布局已经实现了，接下来就是实现图片投影阴影效果。 实现1. 为每个项添加背景图效果&lt;div class=\"list\"&gt; &lt;div class=\"item\" style=\"background-image: url('./1.jpg')\"&gt;&lt;/div&gt; &lt;div class=\"item\" style=\"background-image: url('./2.jpg')\"&gt;&lt;/div&gt; &lt;div class=\"item\" style=\"background-image: url('./3.jpg')\"&gt;&lt;/div&gt; &lt;/div&gt; 同时删掉CSS中注释的那行代码。添加如下代码，让图片填充整个容器，超出部分隐去，并且居中显示，这里看个人喜好： background-size: cover; background-position: center; 效果图： 2. 使用 before 来复制一层图片.item::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: inherit; border-radius: 30px; } 此时，图片重叠，是看不出什么效果的，接下来就是让图片重叠的部分不一样——让它成为一个阴影效果。 3. 使用 filter 来实现阴影 before 的模糊效果在 before 中添加如下代码，模糊度根据你想要的投影大小来设定： filter: blur(30px); 我们可以通过调整 top 等的值来实现位置的指定。这里我设置了 top: 10px;，效果图如下： 可以看到周围已经有了投影的效果，但是图片也有部分内容被遮盖住了，因此我们需要把阴影移到图片后面。 4. 使用 z-index 来调整 before 的层级在 before 中添加如下代码： z-index: -1; 效果图： 5. 调整透明度当我们把模糊度调整较低的时候，会发现阴影的效果不是很明显，跟图片相差过小，因此我们需要调整透明度来增强阴影的效果。 如图： 此时，我们只需要在给 before 设置一个 opacity（透明度）即可： opacity: 0.6; 效果图：","categories":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.bietiaop.com/tags/CSS/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"图片投影","slug":"图片投影","permalink":"https://blog.bietiaop.com/tags/%E5%9B%BE%E7%89%87%E6%8A%95%E5%BD%B1/"},{"name":"图片阴影","slug":"图片阴影","permalink":"https://blog.bietiaop.com/tags/%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/"},{"name":"网站","slug":"网站","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E7%AB%99/"},{"name":"网页","slug":"网页","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E9%A1%B5/"}]},{"title":"[02] React+Vite构建web程序","slug":"web/front/react/Vite+React/[02] Vite + React","date":"2023-03-17T10:38:29.000Z","updated":"2023-03-17T10:38:29.000Z","comments":true,"path":"2023/03/17/web/front/react/vite-react/02-vite-react/","link":"","permalink":"https://blog.bietiaop.com/2023/03/17/web/front/react/vite-react/02-vite-react/","excerpt":"","text":"路由之前已经记过 React Router 的用法。之前提到过 useNavigate，下面学习 useRoute 配置路由 useRoute 配置路由import ...... from ........ import { useRoutes } from \"react-router-dom\"; function App() { let element = useRoutes([ { path: \"/login\", element: &lt;Login /&gt;, children: [ { path: \"about\", element: &lt;About /&gt; }, { path: \"user\", element: &lt;User /&gt; }, ], }, { path: \"/\", element: &lt;Navigate to=\"/login/about\" /&gt; } ]) return element; } 当然这是我们使用 JS 的写，也是官方给的写法，若我们使用 TS，则应该加上类型，例如这样（最好写进一个单独的文件，让 APP 文件导入）： routes.tsx： import ...... from ........ import { useRoutes, RouteObject } from \"react-router-dom\"; const GetRouters = () =&gt; { const routes:RouteObject[] = useRoutes([ { path: \"/login\", element: &lt;Login /&gt;, children: [ { path: \"about\", element: &lt;About /&gt; }, { path: \"user\", element: &lt;User /&gt; }, ], }, { path: \"/\", element: &lt;Navigate to=\"/login/about\" /&gt; } ]) return routes; } export default GetRouters; App.tsx： import ...... from ...... import GetRouters from \"./routes\" function App() { &lt;BrowserRouter&gt; &lt;GetRouters /&gt; &lt;/BrowserRouter&gt; } ...... 当然，我们也可以在 routes.tsx 页面中仅写入数组，在 App.tsx 进行 useRoutes，全看个人喜好。 如果我们在 App.tsx 还有 Layout 布局等，可以直接将此路由标签写入布局。 useLocation 获取当前地址import { useLocation } from 'react-router-dom'; function SomeCom(props: {children: JSX.Element}) { const { pathname } = useLocation() // 获取路径 ...... } 更多用法参考官方文档 组件懒加载React Suspenseimport { lazy, Suspense } from 'react'; const Login = lazy(() =&gt; import('./Login')); function App() { return ( &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;} &gt; &lt;Login /&gt; &lt;/Suspense&gt; ) } 路由懒加载的效果就是在加载的时候显示 Loading...（也可以是自定义组件），加载完成后显示 Login 组件。","categories":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"网站","slug":"网站","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E7%AB%99/"},{"name":"网页","slug":"网页","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E9%A1%B5/"},{"name":"React","slug":"React","permalink":"https://blog.bietiaop.com/tags/React/"},{"name":"Vite","slug":"Vite","permalink":"https://blog.bietiaop.com/tags/Vite/"}]},{"title":"[01] React+Vite构建web程序","slug":"web/front/react/Vite+React/[01] Vite + React","date":"2023-03-16T08:01:44.000Z","updated":"2023-03-16T08:01:44.000Z","comments":true,"path":"2023/03/16/web/front/react/vite-react/01-vite-react/","link":"","permalink":"https://blog.bietiaop.com/2023/03/16/web/front/react/vite-react/01-vite-react/","excerpt":"","text":"环境配置Vite 构建 React 项目我们可以通过附加的命令行选项直接指定项目名称和我们想使用的模板，通过这个，我们可以快速通过 Vite 构建 React 应用 npm create vite@latest yourname --template react # 或者 ts 版 npm create vite@latest yourname --template react-ts 当然，我们可以先不指定模板，到时候 Vite 会让我们进行选择： npm create vite@latest &lt;name&gt; 配置完之后，会看到提示我们运行命令： Done. Now run: cd yourname npm install npm run dev 我们只需要按照要求运行即可 之后我们就可以通过命令运行测试了 配置全局 Scss安装 sassnpm install sass -D 创建 Scss 配置文件在 ./src/styles/ 下创建 sassConfig.scss 可以写入一些全局变量如： $red: red; 配置 Vitevite.config.ts： export default defineConfig({ plugins: [react()], // 配置 scss css: { preprocessorOptions: { scss: { additionalData: `@import \"./src/styles/sassConfig.scss\";` } } } }) 注意在最新版本已经无需手动设置 SCSS 的配置，只需要安装 SASS 即可。 不过仍然可以使用上述配置进行全局 SCSS 的配置。","categories":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"网站","slug":"网站","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E7%AB%99/"},{"name":"网页","slug":"网页","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E9%A1%B5/"},{"name":"React","slug":"React","permalink":"https://blog.bietiaop.com/tags/React/"},{"name":"Vite","slug":"Vite","permalink":"https://blog.bietiaop.com/tags/Vite/"}]},{"title":"React Router 使用","slug":"web/front/react/React Router","date":"2023-03-11T14:30:15.000Z","updated":"2023-03-12T02:07:18.000Z","comments":true,"path":"2023/03/11/web/front/react/react-router/","link":"","permalink":"https://blog.bietiaop.com/2023/03/11/web/front/react/react-router/","excerpt":"","text":"React Router 官网：https://reactrouter.com 首先安装 React Router： npm install react-router-dom -S 核心组件 - BrowserRouter作用：包裹整个应用，一个 React 应用只需要使用一次 两种常用 Router：HashRouter（如果使用Electron，推荐使用这个） 和 BrowserRouter (如果构建web，推荐使用这个) function App() { return ( &lt;BrowserRouter&gt; &lt;Link to=\"/\"&gt;首页&lt;/Link&gt; &lt;Link to=\"/about\"&gt;关于&lt;/Link&gt; &lt;Routes&gt; &lt;Route path=\"/\" element={ &lt;Home /&gt; }&gt;&lt;/Route&gt; &lt;Route path=\"/about\" element={ &lt;About /&gt;}&gt;&lt;/Route&gt; &lt;/BrowserRouter&gt; ) } 核心组件 - Link作用：用于指定导航链接，完成路由转跳 语法说明：组件通过 to 属性指定路由地址，最终会渲染为 a 链接元素 &lt;Link to=\"/path\"&gt;页面一&lt;/Link&gt; 核心组件 - Routes作用：提供一个路由出口，满足条件的路由组件会渲染到组件内部 &lt;Routes&gt; {/* 满足条件的路由组件会渲染到这里 */} &lt;Route /&gt; &lt;Route /&gt; &lt;/Routes&gt; 核心组件 - Route作用：用于指定导航链接，完成路由匹配 &lt;Route path=\"/about\" element={ &lt;About/&gt; }/&gt; 说明：当路径为 /about 时，会渲染 About 组件 编程式导航跳转作用：通过 JS 编程的方式进行路由页面转跳，比如从登录页转到关于页 语法说明： 导入 useNavigate 钩子函数 执行钩子函数得到转跳函数 执行转跳函数完成转跳 import { useNavigate } from 'react-router-dom' const Login = () =&gt; { const navigage = useNavigate() const goAbout = () =&gt; { navigage('/about',{ replace: true }) // 如果为 true，会以替换的方式进行跳转（无法返回上一页），而不是叠加。 } return ( &lt;div&gt; Login &lt;button onClick={ goAbout }&gt;转跳关于&lt;/button&gt; &lt;/div&gt; ) } export default Login 与 Routes 和 useRoutes 一样，也有 Navigate，可直接使用（与 Link 类似），结合 Route 可以实现重定向： &lt;Route path=\"/\" element={&lt;Navigate to=\"/about\" /&gt;}&gt;&lt;/Route&gt; 转跳携带跳转参数场景：有些时候不光需要跳转路由还需要传递参数 两种方式： searchParams 传参传参： navigage('/about?id=1001') 取参 let [params] = useSearchParams() let id = params.get('id') params 传参首先要在 Routes 定义名称： ... &lt;Routes&gt; ... &lt;Route path=\"/about/:id\" element={&lt;About /&gt;}&gt;&lt;/Route&gt; ... &lt;/Routes&gt; ... 传参： navigage('/about/1001') 取参 let params = useParams() let id = params.id 嵌套路由实现 App.js：定义嵌套路由声明&lt;Routes&gt; {/* 定义嵌套关系 */} &lt;Route path='/' element={&lt;Layout /&gt;}&gt; &lt;Route path='board' element={&lt;Board /&gt;} /&gt; &lt;Route path='article' element={&lt;Article /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; Layout.js：使用 &lt;Outlet /&gt; 指定二级路由出口import { Outlet } from 'react-router-dom' function Layout () { return ( &lt;div&gt; layout {/* 二级路由出口 */} &lt;Outlet /&gt; &lt;/div&gt; ) } 默认二级路由设置设置默认显示的二级路由页面： App.js： &lt;Routes&gt; {/* 定义嵌套关系 */} &lt;Route path='/' element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Board /&gt;} /&gt; {/* 将 path 改为 index */} &lt;Route path='article' element={&lt;Article /&gt;} /&gt; &lt;/Route&gt; &lt;/Routes&gt; 404 页配置 &lt;Routes&gt; {/* 定义嵌套关系 */} &lt;Route path='/' element={&lt;Layout /&gt;}&gt; &lt;Route index element={&lt;Board /&gt;} /&gt; &lt;Route path='article' element={&lt;Article /&gt;} /&gt; &lt;/Route&gt; {/* 当所有路径都没有匹配到时渲染此路由 */} &lt;Route path='*' element={&lt;NotFound /&gt;} /&gt; &lt;/Routes&gt; 在 Github Pages 中，如果使用 BrowserRouter，刷新页面会出现 404，对于这个问题，参考如下： react部署到github pages教程及路由匹配问题 对于 vercel，可以写一个 vercel.json 文件，放置在根目录下（确保打包后在根目录），内容如下： { \"routes\": [ { \"src\": \"/[^.]+\", \"dest\": \"/\", \"status\": 200 } ] } 一般来说放到 public 文件夹下。","categories":[{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"React","slug":"React","permalink":"https://blog.bietiaop.com/tags/React/"},{"name":"React Router","slug":"React-Router","permalink":"https://blog.bietiaop.com/tags/React-Router/"}]},{"title":"🎨 配色《花未眠》","slug":"design/配色","date":"2023-03-11T11:49:18.000Z","updated":"2023-03-11T11:49:18.000Z","comments":true,"path":"2023/03/11/design/pei-se/","link":"","permalink":"https://blog.bietiaop.com/2023/03/11/design/pei-se/","excerpt":"","text":"摄影中的配色依然可以运用到网页中去，让网页配色看起来更协调、更清新。 《花未眠》原视频地址：审美提升 |《花未眠》| 高级感配色 | 美学集 #184995 RGB：(24,73,149) #B17AA1 RGB：(117,122,161) #F5B6A4 RGB：(245,182,164) #E290BD RGB：(226,144,189) #4D739A RGB：(77,115,154) #8A4730 RGB：(138,71,48) #FDD19F RGB：(253,209,159) #C67120 RGB：(198,113,32) #12246C RGB：(18,36,108) #FAA563 RGB：(250,165,99) #105D67 RGB：(16,93,103) #2C3113 RGB：(44,49,19) #FBE6D8 RGB：(251,230,216) #6A95B5 RGB：(106,149,181) #E68742 RGB：(230,135,66) #F6A441 RGB：(246,164,65) #6A95B5 RGB：(2,54,138) #351F21 RGB：(53,31,33) #FAB35B RGB：(250,179,91) #136885 RGB：(19,104,133) #7AA4B2 RGB：(122,164,178) #FFC8C8 RGB：(255,200,203) #3C7098 RGB：(60,112,152) #EC9134 RGB：(236,145,52) #E2DCDD RGB：(226,220,221) #0F86BE RGB：(15,134,190) #FB9B57 RGB：(251,155,87) #34718D RGB：(52,113,141) #A90E10 RGB：(169,14,16) #184B45 RGB：(24,75,69) #1475BC RGB：(20,117,188) #B44517 RGB：(180,69,23) #681B18 RGB：(104,27,24) #538DA8 RGB：(83,141,168) #FBB98F RGB：(251,185,143) #7F4722 RGB：(127,71,34) #2861B8 RGB：(40,97,184) #F6E2FD RGB：(246,226,253) #707C9F RGB：(112,124,159)","categories":[{"name":"设计","slug":"设计","permalink":"https://blog.bietiaop.com/categories/%E8%AE%BE%E8%AE%A1/"},{"name":"前端","slug":"设计/前端","permalink":"https://blog.bietiaop.com/categories/%E8%AE%BE%E8%AE%A1/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"配色","slug":"配色","permalink":"https://blog.bietiaop.com/tags/%E9%85%8D%E8%89%B2/"},{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"设计","slug":"设计","permalink":"https://blog.bietiaop.com/tags/%E8%AE%BE%E8%AE%A1/"}]}],"categories":[{"name":"Github","slug":"Github","permalink":"https://blog.bietiaop.com/categories/Github/"},{"name":"学生认证","slug":"Github/学生认证","permalink":"https://blog.bietiaop.com/categories/Github/%E5%AD%A6%E7%94%9F%E8%AE%A4%E8%AF%81/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.bietiaop.com/categories/Rust/"},{"name":"编程","slug":"Rust/编程","permalink":"https://blog.bietiaop.com/categories/Rust/%E7%BC%96%E7%A8%8B/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/categories/web/"},{"name":"前端","slug":"web/前端","permalink":"https://blog.bietiaop.com/categories/web/%E5%89%8D%E7%AB%AF/"},{"name":"Flutter","slug":"Flutter","permalink":"https://blog.bietiaop.com/categories/Flutter/"},{"name":"前端","slug":"Flutter/前端","permalink":"https://blog.bietiaop.com/categories/Flutter/%E5%89%8D%E7%AB%AF/"},{"name":"Vite","slug":"Vite","permalink":"https://blog.bietiaop.com/categories/Vite/"},{"name":"前端","slug":"Vite/前端","permalink":"https://blog.bietiaop.com/categories/Vite/%E5%89%8D%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.bietiaop.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"数据库/后端","permalink":"https://blog.bietiaop.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%90%8E%E7%AB%AF/"},{"name":"设计","slug":"设计","permalink":"https://blog.bietiaop.com/categories/%E8%AE%BE%E8%AE%A1/"},{"name":"前端","slug":"设计/前端","permalink":"https://blog.bietiaop.com/categories/%E8%AE%BE%E8%AE%A1/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Github","slug":"Github","permalink":"https://blog.bietiaop.com/tags/Github/"},{"name":"学生认证","slug":"学生认证","permalink":"https://blog.bietiaop.com/tags/%E5%AD%A6%E7%94%9F%E8%AE%A4%E8%AF%81/"},{"name":"申请指南","slug":"申请指南","permalink":"https://blog.bietiaop.com/tags/%E7%94%B3%E8%AF%B7%E6%8C%87%E5%8D%97/"},{"name":"避坑","slug":"避坑","permalink":"https://blog.bietiaop.com/tags/%E9%81%BF%E5%9D%91/"},{"name":"Rust","slug":"Rust","permalink":"https://blog.bietiaop.com/tags/Rust/"},{"name":"编程","slug":"编程","permalink":"https://blog.bietiaop.com/tags/%E7%BC%96%E7%A8%8B/"},{"name":"前端","slug":"前端","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"web","slug":"web","permalink":"https://blog.bietiaop.com/tags/web/"},{"name":"Canvas","slug":"Canvas","permalink":"https://blog.bietiaop.com/tags/Canvas/"},{"name":"Flutter","slug":"Flutter","permalink":"https://blog.bietiaop.com/tags/Flutter/"},{"name":"GetX","slug":"GetX","permalink":"https://blog.bietiaop.com/tags/GetX/"},{"name":"安卓应用开发","slug":"安卓应用开发","permalink":"https://blog.bietiaop.com/tags/%E5%AE%89%E5%8D%93%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"Android应用开发","slug":"Android应用开发","permalink":"https://blog.bietiaop.com/tags/Android%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"iOS应用开发","slug":"iOS应用开发","permalink":"https://blog.bietiaop.com/tags/iOS%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.bietiaop.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://blog.bietiaop.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"blog","slug":"blog","permalink":"https://blog.bietiaop.com/tags/blog/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.bietiaop.com/tags/CSS/"},{"name":"网站","slug":"网站","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E7%AB%99/"},{"name":"网页","slug":"网页","permalink":"https://blog.bietiaop.com/tags/%E7%BD%91%E9%A1%B5/"},{"name":"字体切割","slug":"字体切割","permalink":"https://blog.bietiaop.com/tags/%E5%AD%97%E4%BD%93%E5%88%87%E5%89%B2/"},{"name":"前端字体","slug":"前端字体","permalink":"https://blog.bietiaop.com/tags/%E5%89%8D%E7%AB%AF%E5%AD%97%E4%BD%93/"},{"name":"gzip","slug":"gzip","permalink":"https://blog.bietiaop.com/tags/gzip/"},{"name":"br","slug":"br","permalink":"https://blog.bietiaop.com/tags/br/"},{"name":"Vite","slug":"Vite","permalink":"https://blog.bietiaop.com/tags/Vite/"},{"name":"Vite插件","slug":"Vite插件","permalink":"https://blog.bietiaop.com/tags/Vite%E6%8F%92%E4%BB%B6/"},{"name":"压缩","slug":"压缩","permalink":"https://blog.bietiaop.com/tags/%E5%8E%8B%E7%BC%A9/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.bietiaop.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"后端","slug":"后端","permalink":"https://blog.bietiaop.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"MySql","slug":"MySql","permalink":"https://blog.bietiaop.com/tags/MySql/"},{"name":"查询","slug":"查询","permalink":"https://blog.bietiaop.com/tags/%E6%9F%A5%E8%AF%A2/"},{"name":"Query","slug":"Query","permalink":"https://blog.bietiaop.com/tags/Query/"},{"name":"React","slug":"React","permalink":"https://blog.bietiaop.com/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://blog.bietiaop.com/tags/Redux/"},{"name":"图片投影","slug":"图片投影","permalink":"https://blog.bietiaop.com/tags/%E5%9B%BE%E7%89%87%E6%8A%95%E5%BD%B1/"},{"name":"图片阴影","slug":"图片阴影","permalink":"https://blog.bietiaop.com/tags/%E5%9B%BE%E7%89%87%E9%98%B4%E5%BD%B1/"},{"name":"React Router","slug":"React-Router","permalink":"https://blog.bietiaop.com/tags/React-Router/"},{"name":"配色","slug":"配色","permalink":"https://blog.bietiaop.com/tags/%E9%85%8D%E8%89%B2/"},{"name":"设计","slug":"设计","permalink":"https://blog.bietiaop.com/tags/%E8%AE%BE%E8%AE%A1/"}]}